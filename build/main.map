{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/buffer-writer/index.js","webpack:///./node_modules/packet-reader/index.js","webpack:///./node_modules/pg-int8/index.js","webpack:///./node_modules/pg-pool/index.js","webpack:///./node_modules/pg/lib/client.js","webpack:///./node_modules/pg/lib/connection-parameters.js","webpack:///./node_modules/pg/lib/connection.js","webpack:///./node_modules/pg/lib/defaults.js","webpack:///./node_modules/pg/lib/index.js","webpack:///./node_modules/pg/lib/native/client.js","webpack:///./node_modules/pg/lib/native/index.js","webpack:///./node_modules/pg/lib/native/query.js","webpack:///./node_modules/pg/lib/query.js","webpack:///./node_modules/pg/lib/result.js","webpack:///./node_modules/pg/lib/sasl.js","webpack:///./node_modules/pg/lib/type-overrides.js","webpack:///./node_modules/pg/lib/utils.js","webpack:///./node_modules/pg/node_modules/pg-connection-string/index.js","webpack:///./node_modules/pg/node_modules/pg-types/index.js","webpack:///./node_modules/pg/node_modules/pg-types/lib/arrayParser.js","webpack:///./node_modules/pg/node_modules/pg-types/lib/binaryParsers.js","webpack:///./node_modules/pg/node_modules/pg-types/lib/builtins.js","webpack:///./node_modules/pg/node_modules/pg-types/lib/textParsers.js","webpack:///./node_modules/pg/node_modules/postgres-array/index.js","webpack:///./node_modules/pg/node_modules/semver/semver.js","webpack:///./node_modules/pgpass/lib/helper.js","webpack:///./node_modules/pgpass/lib/index.js","webpack:///./node_modules/postgres-bytea/index.js","webpack:///./node_modules/postgres-date/index.js","webpack:///./node_modules/postgres-interval/index.js","webpack:///./node_modules/split/index.js","webpack:///./node_modules/through/index.js","webpack:///./node_modules/xtend/mutable.js","webpack:///./src/index.js","webpack:///external \"@graphile-contrib/pg-simplify-inflector\"","webpack:///external \"apollo-server\"","webpack:///external \"assert\"","webpack:///external \"crypto\"","webpack:///external \"dns\"","webpack:///external \"dotenv\"","webpack:///external \"events\"","webpack:///external \"fs\"","webpack:///external \"graphile-utils\"","webpack:///external \"net\"","webpack:///external \"path\"","webpack:///external \"pg-native\"","webpack:///external \"postgraphile-apollo-server\"","webpack:///external \"stream\"","webpack:///external \"string_decoder\"","webpack:///external \"tls\"","webpack:///external \"url\"","webpack:///external \"util\""],"names":["require","config","pg","ApolloServer","makeSchemaAndPlugin","makeExtendSchemaPlugin","gql","PgSimplifyInflectorPlugin","pgPool","Pool","connectionString","process","env","DATABASE_URL","main","schema","plugin","dynamicJson","appendPlugins","server","plugins","url","listen","console","log","catch","e","error","exit"],"mappings":";;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChIA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnGY;AACZ,qBAAqB,mBAAO,CAAC,sBAAQ;;AAErC,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,gDAAgD;AAChD,mDAAmD,mBAAO,CAAC,0CAAI;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7WY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,+CAAS;AAC7B,WAAW,mBAAO,CAAC,6CAAQ;AAC3B,aAAa,mBAAO,CAAC,kDAAQ;AAC7B,oBAAoB,mBAAO,CAAC,iEAAkB;;AAE9C,2BAA2B,mBAAO,CAAC,+EAAyB;AAC5D,YAAY,mBAAO,CAAC,+CAAS;AAC7B,eAAe,mBAAO,CAAC,qDAAY;AACnC,iBAAiB,mBAAO,CAAC,yDAAc;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AChjBY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;;AAEvB,eAAe,mBAAO,CAAC,qDAAY;;AAEnC,YAAY,mBAAO,CAAC,0FAAsB;;AAE1C;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE,oBAAoB;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACxIY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,aAAa,mBAAO,CAAC,4DAAe;AACpC,aAAa,mBAAO,CAAC,4DAAe;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,gBAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,OAAO;AACjC;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA,eAAe,SAAS,OAAO;AAC/B;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChsBY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc,mBAAO,CAAC,kEAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AChFW;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,iDAAU;AAC/B,eAAe,mBAAO,CAAC,qDAAY;AACnC,iBAAiB,mBAAO,CAAC,yDAAc;AACvC,WAAW,mBAAO,CAAC,gDAAS;;AAE5B;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,kEAAU;AACjC;;AAEA;AACA,0BAA0B,mBAAO,CAAC,uDAAU;AAC5C,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,uDAAU;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1DY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,4BAAW;AAChC,oBAAoB,mBAAO,CAAC,kEAAmB;AAC/C,aAAa,mBAAO,CAAC,+DAAQ;AAC7B,UAAU,mBAAO,CAAC,0DAAoB;AACtC,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,WAAW,mBAAO,CAAC,kBAAM;AACzB,2BAA2B,mBAAO,CAAC,gFAA0B;;AAE7D;AACA;;AAEA,kBAAkB,mBAAO,CAAC,sDAAS;;AAEnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mDAAmD,EAAE;AACrD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtSY;AACZ,iBAAiB,mBAAO,CAAC,wDAAU;;;;;;;;;;;;;ACDvB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,gDAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAuE,UAAU;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;ACtKY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,aAAa,mBAAO,CAAC,iDAAU;AAC/B,YAAY,mBAAO,CAAC,+CAAS;;AAE7B;AACA;AACA,iCAAiC;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA,mBAAmB;AACnB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpOY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,kEAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtGY;AACZ,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,GAAG;AACH,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,kEAAU;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtCY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,iBAAiB,mBAAO,CAAC,qDAAY;;AAErC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,OAAO;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;AChLa;;AAEb,UAAU,mBAAO,CAAC,gBAAK;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC7DA,kBAAkB,mBAAO,CAAC,qFAAmB;AAC7C,oBAAoB,mBAAO,CAAC,yFAAqB;AACjD,kBAAkB,mBAAO,CAAC,qFAAmB;AAC7C,mBAAmB,mBAAO,CAAC,+EAAgB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;;;;;;;;;;;AC9CD,YAAY,mBAAO,CAAC,8EAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA,iBAAiB,mBAAO,CAAC,gDAAS;;AAElC;AACA;AACA;AACA,8DAA8D,mDAAmD;AACjH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AChQA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxEA,YAAY,mBAAO,CAAC,8EAAgB;AACpC,kBAAkB,mBAAO,CAAC,iFAAe;AACzC,gBAAgB,mBAAO,CAAC,4DAAe;AACvC,oBAAoB,mBAAO,CAAC,oEAAmB;AAC/C,iBAAiB,mBAAO,CAAC,8DAAgB;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,cAAc,aAAa;;AAE3B;AACA;AACA;;AAEA;AACA,eAAe,aAAa;;AAE5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,eAAe,aAAa;;AAE5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,eAAe,aAAa;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;;AAEA;AACA,eAAe,aAAa;;AAE5B;AACA;;AAEA;AACA,yBAAyB,aAAa;;AAEtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,aAAa;;AAE1D;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC;AAChC,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,kCAAkC;AAClC,6BAA6B;AAC7B;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC,oCAAoC;AACpC,uCAAuC;AACvC,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;AAClC,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA,uCAAuC;AACvC,wCAAwC;AACxC,gCAAgC;AAChC,iCAAiC;AACjC,mCAAmC;AACnC,mCAAmC;AACnC,kCAAkC;AAClC,mCAAmC;AACnC,mCAAmC;AACnC;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtNY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gCAAgC;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AChGA;AACA,IAAI,KAA0B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC,oCAAoC;AACpC,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,IAA0C;AAC9C,EAAE,oCAAO,OAAO;AAAA;AAAA;AAAA;AAAA,oGAAC;;;;;;;;;;;;;;;;;;;;;;;;ACtqCJ;;AAEb,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,YAAY,mBAAO,CAAC,4CAAO;AAC3B,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACvOa;;AAEb,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;AACrB,aAAa,mBAAO,CAAC,wDAAa;AAClC;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;;;ACtBY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,EAAE;AACnB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BY;;AAEZ,qBAAqB,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,GAAG;AAC1E,iBAAiB,GAAG,MAAM,EAAE,MAAM,EAAE;AACpC,4BAA4B,EAAE,QAAQ,EAAE,QAAQ,EAAE;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7GY;;AAEZ,aAAa,mBAAO,CAAC,sDAAe;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;;;;;;;;;;;AC5HA;;AAEA;AACA;AACA;;;AAGA,cAAc,mBAAO,CAAC,gDAAS;AAC/B,cAAc,mBAAO,CAAC,sCAAgB;;AAEtC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC9DA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oCAAoC;AACpC,4BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1GA;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AChBAA,mBAAO,CAAC,sBAAD,CAAP,CAAkBC,MAAlB;;AAEA,MAAMC,EAAE,GAAGF,mBAAO,CAAC,0CAAD,CAAlB;;AACA,MAAM;AAAEG;AAAF,IAAmBH,mBAAO,CAAC,oCAAD,CAAhC;;AACA,MAAM;AAAEI;AAAF,IAA0BJ,mBAAO,CAAC,8DAAD,CAAvC;;AACA,MAAM;AAAEK,wBAAF;AAA0BC;AAA1B,IAAkCN,mBAAO,CAAC,sCAAD,CAA/C;;AACA,MAAMO,yBAAyB,GAAGP,mBAAO,CAAC,wFAAD,CAAzC;;AAEA,MAAMQ,MAAM,GAAG,IAAIN,EAAE,CAACO,IAAP,CAAY;AACzBC,kBAAgB,EAAEC,OAAO,CAACC,GAAR,CAAYC;AADL,CAAZ,CAAf;;AAIA,eAAeC,IAAf,GAAsB;AACpB,QAAM;AAAEC,UAAF;AAAUC;AAAV,MAAqB,MAAMZ,mBAAmB,CAClDI,MADkD,EAElD,QAFkD,EAGlD;AACE;AACA;AACAS,eAAW,EAAE,IAHf;AAIEC,iBAAa,EAAE,CACbX,yBADa;AAJjB,GAHkD,CAApD;AAcA,QAAMY,MAAM,GAAG,IAAIhB,YAAJ,CAAiB;AAC9BY,UAD8B;AAE9BK,WAAO,EAAE,CAACJ,MAAD;AAFqB,GAAjB,CAAf;AAKA,QAAM;AAAEK;AAAF,MAAU,MAAMF,MAAM,CAACG,MAAP,EAAtB;AACAC,SAAO,CAACC,GAAR,CAAa,sBAAqBH,GAAI,EAAtC;AACD;;AAEDP,IAAI,GAAGW,KAAP,CAAaC,CAAC,IAAI;AAChBH,SAAO,CAACI,KAAR,CAAcD,CAAd;AACAf,SAAO,CAACiB,IAAR,CAAa,CAAb;AACD,CAHD,E;;;;;;;;;;;;;;;;;;;;;;;ACpCA,oE;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,2C;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,uD;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,2C;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","//binary data writer tuned for creating\n//postgres message packets as effeciently as possible by reusing the\n//same buffer to avoid memcpy and limit memory allocations\nvar Writer = module.exports = function (size) {\n  this.size = size || 1024;\n  this.buffer = Buffer.alloc(this.size + 5);\n  this.offset = 5;\n  this.headerPosition = 0;\n};\n\n//resizes internal buffer if not enough size left\nWriter.prototype._ensure = function (size) {\n  var remaining = this.buffer.length - this.offset;\n  if (remaining < size) {\n    var oldBuffer = this.buffer;\n    // exponential growth factor of around ~ 1.5\n    // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\n    var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;\n    this.buffer = Buffer.alloc(newSize);\n    oldBuffer.copy(this.buffer);\n  }\n};\n\nWriter.prototype.addInt32 = function (num) {\n  this._ensure(4);\n  this.buffer[this.offset++] = (num >>> 24 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 16 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 8 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 0 & 0xFF);\n  return this;\n};\n\nWriter.prototype.addInt16 = function (num) {\n  this._ensure(2);\n  this.buffer[this.offset++] = (num >>> 8 & 0xFF);\n  this.buffer[this.offset++] = (num >>> 0 & 0xFF);\n  return this;\n};\n\n//for versions of node requiring 'length' as 3rd argument to buffer.write\nvar writeString = function (buffer, string, offset, len) {\n  buffer.write(string, offset, len);\n};\n\n//overwrite function for older versions of node\nif (Buffer.prototype.write.length === 3) {\n  writeString = function (buffer, string, offset, len) {\n    buffer.write(string, offset);\n  };\n}\n\nWriter.prototype.addCString = function (string) {\n  //just write a 0 for empty or null strings\n  if (!string) {\n    this._ensure(1);\n  } else {\n    var len = Buffer.byteLength(string);\n    this._ensure(len + 1); //+1 for null terminator\n    writeString(this.buffer, string, this.offset, len);\n    this.offset += len;\n  }\n\n  this.buffer[this.offset++] = 0; // null terminator\n  return this;\n};\n\nWriter.prototype.addChar = function (c) {\n  this._ensure(1);\n  writeString(this.buffer, c, this.offset, 1);\n  this.offset++;\n  return this;\n};\n\nWriter.prototype.addString = function (string) {\n  string = string || \"\";\n  var len = Buffer.byteLength(string);\n  this._ensure(len);\n  this.buffer.write(string, this.offset);\n  this.offset += len;\n  return this;\n};\n\nWriter.prototype.getByteLength = function () {\n  return this.offset - 5;\n};\n\nWriter.prototype.add = function (otherBuffer) {\n  this._ensure(otherBuffer.length);\n  otherBuffer.copy(this.buffer, this.offset);\n  this.offset += otherBuffer.length;\n  return this;\n};\n\nWriter.prototype.clear = function () {\n  this.offset = 5;\n  this.headerPosition = 0;\n  this.lastEnd = 0;\n};\n\n//appends a header block to all the written data since the last\n//subsequent header or to the beginning if there is only one data block\nWriter.prototype.addHeader = function (code, last) {\n  var origOffset = this.offset;\n  this.offset = this.headerPosition;\n  this.buffer[this.offset++] = code;\n  //length is everything in this packet minus the code\n  this.addInt32(origOffset - (this.headerPosition + 1));\n  //set next header position\n  this.headerPosition = origOffset;\n  //make space for next header\n  this.offset = origOffset;\n  if (!last) {\n    this._ensure(5);\n    this.offset += 5;\n  }\n};\n\nWriter.prototype.join = function (code) {\n  if (code) {\n    this.addHeader(code, true);\n  }\n  return this.buffer.slice(code ? 0 : 5, this.offset);\n};\n\nWriter.prototype.flush = function (code) {\n  var result = this.join(code);\n  this.clear();\n  return result;\n};\n","var assert = require('assert')\n\nvar Reader = module.exports = function(options) {\n  //TODO - remove for version 1.0\n  if(typeof options == 'number') {\n    options = { headerSize: options }\n  }\n  options = options || {}\n  this.offset = 0\n  this.lastChunk = false\n  this.chunk = null\n  this.chunkLength = 0\n  this.headerSize = options.headerSize || 0\n  this.lengthPadding = options.lengthPadding || 0\n  this.header = null\n  assert(this.headerSize < 2, 'pre-length header of more than 1 byte length not currently supported')\n}\n\nReader.prototype.addChunk = function(chunk) {\n  if (!this.chunk || this.offset === this.chunkLength) {\n    this.chunk = chunk\n    this.chunkLength = chunk.length\n    this.offset = 0\n    return\n  }\n\n  var newChunkLength = chunk.length\n  var newLength = this.chunkLength + newChunkLength\n\n  if (newLength > this.chunk.length) {\n    var newBufferLength = this.chunk.length * 2\n    while (newLength >= newBufferLength) {\n      newBufferLength *= 2\n    }\n    var newBuffer = Buffer.alloc(newBufferLength)\n    this.chunk.copy(newBuffer)\n    this.chunk = newBuffer\n  }\n  chunk.copy(this.chunk, this.chunkLength)\n  this.chunkLength = newLength\n}\n\nReader.prototype.read = function() {\n  if(this.chunkLength < (this.headerSize + 4 + this.offset)) {\n    return false\n  }\n\n  if(this.headerSize) {\n    this.header = this.chunk[this.offset]\n  }\n\n  //read length of next item\n  var length = this.chunk.readUInt32BE(this.offset + this.headerSize) + this.lengthPadding\n\n  //next item spans more chunks than we have\n  var remaining = this.chunkLength - (this.offset + 4 + this.headerSize)\n  if(length > remaining) {\n    return false\n  }\n\n  this.offset += (this.headerSize + 4)\n  var result = this.chunk.slice(this.offset, this.offset + length)\n  this.offset += length\n  return result\n}\n","'use strict';\n\n// selected so (BASE - 1) * 0x100000000 + 0xffffffff is a safe integer\nvar BASE = 1000000;\n\nfunction readInt8(buffer) {\n\tvar high = buffer.readInt32BE(0);\n\tvar low = buffer.readUInt32BE(4);\n\tvar sign = '';\n\n\tif (high < 0) {\n\t\thigh = ~high + (low === 0);\n\t\tlow = (~low + 1) >>> 0;\n\t\tsign = '-';\n\t}\n\n\tvar result = '';\n\tvar carry;\n\tvar t;\n\tvar digits;\n\tvar pad;\n\tvar l;\n\tvar i;\n\n\t{\n\t\tcarry = high % BASE;\n\t\thigh = high / BASE >>> 0;\n\n\t\tt = 0x100000000 * carry + low;\n\t\tlow = t / BASE >>> 0;\n\t\tdigits = '' + (t - BASE * low);\n\n\t\tif (low === 0 && high === 0) {\n\t\t\treturn sign + digits + result;\n\t\t}\n\n\t\tpad = '';\n\t\tl = 6 - digits.length;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpad += '0';\n\t\t}\n\n\t\tresult = pad + digits + result;\n\t}\n\n\t{\n\t\tcarry = high % BASE;\n\t\thigh = high / BASE >>> 0;\n\n\t\tt = 0x100000000 * carry + low;\n\t\tlow = t / BASE >>> 0;\n\t\tdigits = '' + (t - BASE * low);\n\n\t\tif (low === 0 && high === 0) {\n\t\t\treturn sign + digits + result;\n\t\t}\n\n\t\tpad = '';\n\t\tl = 6 - digits.length;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpad += '0';\n\t\t}\n\n\t\tresult = pad + digits + result;\n\t}\n\n\t{\n\t\tcarry = high % BASE;\n\t\thigh = high / BASE >>> 0;\n\n\t\tt = 0x100000000 * carry + low;\n\t\tlow = t / BASE >>> 0;\n\t\tdigits = '' + (t - BASE * low);\n\n\t\tif (low === 0 && high === 0) {\n\t\t\treturn sign + digits + result;\n\t\t}\n\n\t\tpad = '';\n\t\tl = 6 - digits.length;\n\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tpad += '0';\n\t\t}\n\n\t\tresult = pad + digits + result;\n\t}\n\n\t{\n\t\tcarry = high % BASE;\n\t\tt = 0x100000000 * carry + low;\n\t\tdigits = '' + t % BASE;\n\n\t\treturn sign + digits + result;\n\t}\n}\n\nmodule.exports = readInt8;\n","'use strict'\nconst EventEmitter = require('events').EventEmitter\n\nconst NOOP = function () { }\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1\n    ? undefined\n    : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor (client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor (callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnRelease () {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify (Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener (pool, client) {\n  return function idleListener (err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor (options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.log = this.options.log || function () { }\n    this.Client = this.options.Client || Client || require('pg').Client\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull () {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue () {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map(item => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove (client) {\n    const removed = removeWhere(\n      this._idle,\n      item => item.client === client\n    )\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter(c => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect (cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._clients.length >= this.options.max || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient (pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter(c => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client wont be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient (client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    let released = false\n\n    client.release = (err) => {\n      if (released) {\n        throwOnRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release (client, idleListener, err) {\n    client.on('error', idleListener)\n\n    if (err || this.ending) {\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query (text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n      this.log('dispatching query')\n      client.query(text, values, (err, res) => {\n        this.log('query dispatched')\n        client.release(err)\n        if (err) {\n          return cb(err)\n        } else {\n          return cb(undefined, res)\n        }\n      })\n    })\n    return response.result\n  }\n\n  end (cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount () {\n    return this._pendingQueue.length\n  }\n\n  get idleCount () {\n    return this._idle.length\n  }\n\n  get totalCount () {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar utils = require('./utils')\nvar sasl = require('./sasl')\nvar pgPass = require('pgpass')\nvar TypeOverrides = require('./type-overrides')\n\nvar ConnectionParameters = require('./connection-parameters')\nvar Query = require('./query')\nvar defaults = require('./defaults')\nvar Connection = require('./connection')\n\nvar Client = function (config) {\n  EventEmitter.call(this)\n\n  this.connectionParameters = new ConnectionParameters(config)\n  this.user = this.connectionParameters.user\n  this.database = this.connectionParameters.database\n  this.port = this.connectionParameters.port\n  this.host = this.connectionParameters.host\n  this.password = this.connectionParameters.password\n  this.replication = this.connectionParameters.replication\n\n  var c = config || {}\n\n  this._Promise = c.Promise || global.Promise\n  this._types = new TypeOverrides(c.types)\n  this._ending = false\n  this._connecting = false\n  this._connected = false\n  this._connectionError = false\n  this._queryable = true\n\n  this.connection = c.connection || new Connection({\n    stream: c.stream,\n    ssl: this.connectionParameters.ssl,\n    keepAlive: c.keepAlive || false,\n    keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n    encoding: this.connectionParameters.client_encoding || 'utf8'\n  })\n  this.queryQueue = []\n  this.binary = c.binary || defaults.binary\n  this.processID = null\n  this.secretKey = null\n  this.ssl = this.connectionParameters.ssl || false\n  this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n}\n\nutil.inherits(Client, EventEmitter)\n\nClient.prototype._errorAllQueries = function (err) {\n  const enqueueError = (query) => {\n    process.nextTick(() => {\n      query.handleError(err, this.connection)\n    })\n  }\n\n  if (this.activeQuery) {\n    enqueueError(this.activeQuery)\n    this.activeQuery = null\n  }\n\n  this.queryQueue.forEach(enqueueError)\n  this.queryQueue.length = 0\n}\n\nClient.prototype._connect = function (callback) {\n  var self = this\n  var con = this.connection\n  if (this._connecting || this._connected) {\n    const err = new Error('Client has already been connected. You cannot reuse a client.')\n    process.nextTick(() => {\n      callback(err)\n    })\n    return\n  }\n  this._connecting = true\n\n  var connectionTimeoutHandle\n  if (this._connectionTimeoutMillis > 0) {\n    connectionTimeoutHandle = setTimeout(() => {\n      con._ending = true\n      con.stream.destroy(new Error('timeout expired'))\n    }, this._connectionTimeoutMillis)\n  }\n\n  if (this.host && this.host.indexOf('/') === 0) {\n    con.connect(this.host + '/.s.PGSQL.' + this.port)\n  } else {\n    con.connect(this.port, this.host)\n  }\n\n  // once connection is established send startup message\n  con.on('connect', function () {\n    if (self.ssl) {\n      con.requestSsl()\n    } else {\n      con.startup(self.getStartupConf())\n    }\n  })\n\n  con.on('sslconnect', function () {\n    con.startup(self.getStartupConf())\n  })\n\n  function checkPgPass (cb) {\n    return function (msg) {\n      if (typeof self.password === 'function') {\n        self._Promise.resolve()\n          .then(() => self.password())\n          .then(pass => {\n            if (pass !== undefined) {\n              if (typeof pass !== 'string') {\n                con.emit('error', new TypeError('Password must be a string'))\n                return\n              }\n              self.connectionParameters.password = self.password = pass\n            } else {\n              self.connectionParameters.password = self.password = null\n            }\n            cb(msg)\n          }).catch(err => {\n            con.emit('error', err)\n          })\n      } else if (self.password !== null) {\n        cb(msg)\n      } else {\n        pgPass(self.connectionParameters, function (pass) {\n          if (undefined !== pass) {\n            self.connectionParameters.password = self.password = pass\n          }\n          cb(msg)\n        })\n      }\n    }\n  }\n\n  // password request handling\n  con.on('authenticationCleartextPassword', checkPgPass(function () {\n    con.password(self.password)\n  }))\n\n  // password request handling\n  con.on('authenticationMD5Password', checkPgPass(function (msg) {\n    con.password(utils.postgresMd5PasswordHash(self.user, self.password, msg.salt))\n  }))\n\n  // password request handling (SASL)\n  var saslSession\n  con.on('authenticationSASL', checkPgPass(function (msg) {\n    saslSession = sasl.startSession(msg.mechanisms)\n\n    con.sendSASLInitialResponseMessage(saslSession.mechanism, saslSession.response)\n  }))\n\n  // password request handling (SASL)\n  con.on('authenticationSASLContinue', function (msg) {\n    sasl.continueSession(saslSession, self.password, msg.data)\n\n    con.sendSCRAMClientFinalMessage(saslSession.response)\n  })\n\n  // password request handling (SASL)\n  con.on('authenticationSASLFinal', function (msg) {\n    sasl.finalizeSession(saslSession, msg.data)\n\n    saslSession = null\n  })\n\n  con.once('backendKeyData', function (msg) {\n    self.processID = msg.processID\n    self.secretKey = msg.secretKey\n  })\n\n  const connectingErrorHandler = (err) => {\n    if (this._connectionError) {\n      return\n    }\n    this._connectionError = true\n    clearTimeout(connectionTimeoutHandle)\n    if (callback) {\n      return callback(err)\n    }\n    this.emit('error', err)\n  }\n\n  const connectedErrorHandler = (err) => {\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  const connectedErrorMessageHandler = (msg) => {\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      connectedErrorHandler(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, con)\n  }\n\n  con.on('error', connectingErrorHandler)\n  con.on('errorMessage', connectingErrorHandler)\n\n  // hook up query handling events to connection\n  // after the connection initially becomes ready for queries\n  con.once('readyForQuery', function () {\n    self._connecting = false\n    self._connected = true\n    self._attachListeners(con)\n    con.removeListener('error', connectingErrorHandler)\n    con.removeListener('errorMessage', connectingErrorHandler)\n    con.on('error', connectedErrorHandler)\n    con.on('errorMessage', connectedErrorMessageHandler)\n    clearTimeout(connectionTimeoutHandle)\n\n    // process possible callback argument to Client#connect\n    if (callback) {\n      callback(null, self)\n      // remove callback for proper error handling\n      // after the connect event\n      callback = null\n    }\n    self.emit('connect')\n  })\n\n  con.on('readyForQuery', function () {\n    var activeQuery = self.activeQuery\n    self.activeQuery = null\n    self.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(con)\n    }\n    self._pulseQueryQueue()\n  })\n\n  con.once('end', () => {\n    const error = this._ending\n      ? new Error('Connection terminated')\n      : new Error('Connection terminated unexpectedly')\n\n    this._errorAllQueries(error)\n\n    if (!this._ending) {\n      // if the connection is ended without us calling .end()\n      // on this client then we have an unexpected disconnection\n      // treat this as an error unless we've already emitted an error\n      // during connection.\n      if (this._connecting && !this._connectionError) {\n        if (callback) {\n          callback(error)\n        } else {\n          connectedErrorHandler(error)\n        }\n      } else if (!this._connectionError) {\n        connectedErrorHandler(error)\n      }\n    }\n\n    process.nextTick(() => {\n      this.emit('end')\n    })\n  })\n\n  con.on('notice', function (msg) {\n    self.emit('notice', msg)\n  })\n}\n\nClient.prototype.connect = function (callback) {\n  if (callback) {\n    this._connect(callback)\n    return\n  }\n\n  return new this._Promise((resolve, reject) => {\n    this._connect((error) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\nClient.prototype._attachListeners = function (con) {\n  const self = this\n  // delegate rowDescription to active query\n  con.on('rowDescription', function (msg) {\n    self.activeQuery.handleRowDescription(msg)\n  })\n\n  // delegate dataRow to active query\n  con.on('dataRow', function (msg) {\n    self.activeQuery.handleDataRow(msg)\n  })\n\n  // delegate portalSuspended to active query\n  // eslint-disable-next-line no-unused-vars\n  con.on('portalSuspended', function (msg) {\n    self.activeQuery.handlePortalSuspended(con)\n  })\n\n  // delegate emptyQuery to active query\n  // eslint-disable-next-line no-unused-vars\n  con.on('emptyQuery', function (msg) {\n    self.activeQuery.handleEmptyQuery(con)\n  })\n\n  // delegate commandComplete to active query\n  con.on('commandComplete', function (msg) {\n    self.activeQuery.handleCommandComplete(msg, con)\n  })\n\n  // if a prepared statement has a name and properly parses\n  // we track that its already been executed so we don't parse\n  // it again on the same client\n  // eslint-disable-next-line no-unused-vars\n  con.on('parseComplete', function (msg) {\n    if (self.activeQuery.name) {\n      con.parsedStatements[self.activeQuery.name] = self.activeQuery.text\n    }\n  })\n\n  // eslint-disable-next-line no-unused-vars\n  con.on('copyInResponse', function (msg) {\n    self.activeQuery.handleCopyInResponse(self.connection)\n  })\n\n  con.on('copyData', function (msg) {\n    self.activeQuery.handleCopyData(msg, self.connection)\n  })\n\n  con.on('notification', function (msg) {\n    self.emit('notification', msg)\n  })\n}\n\nClient.prototype.getStartupConf = function () {\n  var params = this.connectionParameters\n\n  var data = {\n    user: params.user,\n    database: params.database\n  }\n\n  var appName = params.application_name || params.fallback_application_name\n  if (appName) {\n    data.application_name = appName\n  }\n  if (params.replication) {\n    data.replication = '' + params.replication\n  }\n  if (params.statement_timeout) {\n    data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n  }\n\n  return data\n}\n\nClient.prototype.cancel = function (client, query) {\n  if (client.activeQuery === query) {\n    var con = this.connection\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send cancel message\n    con.on('connect', function () {\n      con.cancel(client.processID, client.secretKey)\n    })\n  } else if (client.queryQueue.indexOf(query) !== -1) {\n    client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n  }\n}\n\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn)\n}\n\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format)\n}\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nClient.prototype.escapeIdentifier = function (str) {\n  return '\"' + str.replace(/\"/g, '\"\"') + '\"'\n}\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nClient.prototype.escapeLiteral = function (str) {\n  var hasBackslash = false\n  var escaped = '\\''\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str[i]\n    if (c === '\\'') {\n      escaped += c + c\n    } else if (c === '\\\\') {\n      escaped += c + c\n      hasBackslash = true\n    } else {\n      escaped += c\n    }\n  }\n\n  escaped += '\\''\n\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped\n  }\n\n  return escaped\n}\n\nClient.prototype._pulseQueryQueue = function () {\n  if (this.readyForQuery === true) {\n    this.activeQuery = this.queryQueue.shift()\n    if (this.activeQuery) {\n      this.readyForQuery = false\n      this.hasExecuted = true\n\n      const queryError = this.activeQuery.submit(this.connection)\n      if (queryError) {\n        process.nextTick(() => {\n          this.activeQuery.handleError(queryError, this.connection)\n          this.readyForQuery = true\n          this._pulseQueryQueue()\n        })\n      }\n    } else if (this.hasExecuted) {\n      this.activeQuery = null\n      this.emit('drain')\n    }\n  }\n}\n\nClient.prototype.query = function (config, values, callback) {\n  // can take in strings, config object or query object\n  var query\n  var result\n  var readTimeout\n  var readTimeoutTimer\n  var queryCallback\n\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query')\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n    result = query = config\n    if (typeof values === 'function') {\n      query.callback = query.callback || values\n    }\n  } else {\n    readTimeout = this.connectionParameters.query_timeout\n    query = new Query(config, values, callback)\n    if (!query.callback) {\n      result = new this._Promise((resolve, reject) => {\n        query.callback = (err, res) => err ? reject(err) : resolve(res)\n      })\n    }\n  }\n\n  if (readTimeout) {\n    queryCallback = query.callback\n\n    readTimeoutTimer = setTimeout(() => {\n      var error = new Error('Query read timeout')\n\n      process.nextTick(() => {\n        query.handleError(error, this.connection)\n      })\n\n      queryCallback(error)\n\n      // we already returned an error,\n      // just do nothing if query completes\n      query.callback = () => {}\n\n      // Remove from queue\n      var index = this.queryQueue.indexOf(query)\n      if (index > -1) {\n        this.queryQueue.splice(index, 1)\n      }\n\n      this._pulseQueryQueue()\n    }, readTimeout)\n\n    query.callback = (err, res) => {\n      clearTimeout(readTimeoutTimer)\n      queryCallback(err, res)\n    }\n  }\n\n  if (this.binary && !query.binary) {\n    query.binary = true\n  }\n\n  if (query._result && !query._result._types) {\n    query._result._types = this._types\n  }\n\n  if (!this._queryable) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n    })\n    return result\n  }\n\n  if (this._ending) {\n    process.nextTick(() => {\n      query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n    })\n    return result\n  }\n\n  this.queryQueue.push(query)\n  this._pulseQueryQueue()\n  return result\n}\n\nClient.prototype.end = function (cb) {\n  this._ending = true\n\n  if (this.activeQuery) {\n    // if we have an active query we need to force a disconnect\n    // on the socket - otherwise a hung query could block end forever\n    this.connection.stream.destroy()\n  } else {\n    this.connection.end()\n  }\n\n  if (cb) {\n    this.connection.once('end', cb)\n  } else {\n    return new this._Promise((resolve) => {\n      this.connection.once('end', resolve)\n    })\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar dns = require('dns')\n\nvar defaults = require('./defaults')\n\nvar parse = require('pg-connection-string').parse // parses a connection string\n\nvar val = function (key, config, envVar) {\n  if (envVar === undefined) {\n    envVar = process.env['PG' + key.toUpperCase()]\n  } else if (envVar === false) {\n    // do nothing ... use false\n  } else {\n    envVar = process.env[envVar]\n  }\n\n  return config[key] ||\n    envVar ||\n    defaults[key]\n}\n\nvar useSsl = function () {\n  switch (process.env.PGSSLMODE) {\n    case 'disable':\n      return false\n    case 'prefer':\n    case 'require':\n    case 'verify-ca':\n    case 'verify-full':\n      return true\n  }\n  return defaults.ssl\n}\n\nvar ConnectionParameters = function (config) {\n  // if a string is passed, it is a raw connection string so we parse it into a config\n  config = typeof config === 'string' ? parse(config) : config || {}\n\n  // if the config has a connectionString defined, parse IT into the config we use\n  // this will override other default values with what is stored in connectionString\n  if (config.connectionString) {\n    config = Object.assign({}, config, parse(config.connectionString))\n  }\n\n  this.user = val('user', config)\n  this.database = val('database', config)\n  this.port = parseInt(val('port', config), 10)\n  this.host = val('host', config)\n  this.password = val('password', config)\n  this.binary = val('binary', config)\n  this.ssl = typeof config.ssl === 'undefined' ? useSsl() : config.ssl\n  this.client_encoding = val('client_encoding', config)\n  this.replication = val('replication', config)\n  // a domain socket begins with '/'\n  this.isDomainSocket = (!(this.host || '').indexOf('/'))\n\n  this.application_name = val('application_name', config, 'PGAPPNAME')\n  this.fallback_application_name = val('fallback_application_name', config, false)\n  this.statement_timeout = val('statement_timeout', config, false)\n  this.query_timeout = val('query_timeout', config, false)\n\n  if (config.connectionTimeoutMillis === undefined) {\n    this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0\n  } else {\n    this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000)\n  }\n\n  if (config.keepAlive === false) {\n    this.keepalives = 0\n  } else if (config.keepAlive === true) {\n    this.keepalives = 1\n  }\n\n  if (typeof config.keepAliveInitialDelayMillis === 'number') {\n    this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000)\n  }\n}\n\n// Convert arg to a string, surround in single quotes, and escape single quotes and backslashes\nvar quoteParamValue = function (value) {\n  return \"'\" + ('' + value).replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\") + \"'\"\n}\n\nvar add = function (params, config, paramName) {\n  var value = config[paramName]\n  if (value !== undefined && value !== null) {\n    params.push(paramName + '=' + quoteParamValue(value))\n  }\n}\n\nConnectionParameters.prototype.getLibpqConnectionString = function (cb) {\n  var params = []\n  add(params, this, 'user')\n  add(params, this, 'password')\n  add(params, this, 'port')\n  add(params, this, 'application_name')\n  add(params, this, 'fallback_application_name')\n  add(params, this, 'connect_timeout')\n\n  var ssl = typeof this.ssl === 'object' ? this.ssl : this.ssl ? { sslmode: this.ssl } : {}\n  add(params, ssl, 'sslmode')\n  add(params, ssl, 'sslca')\n  add(params, ssl, 'sslkey')\n  add(params, ssl, 'sslcert')\n  add(params, ssl, 'sslrootcert')\n\n  if (this.database) {\n    params.push('dbname=' + quoteParamValue(this.database))\n  }\n  if (this.replication) {\n    params.push('replication=' + quoteParamValue(this.replication))\n  }\n  if (this.host) {\n    params.push('host=' + quoteParamValue(this.host))\n  }\n  if (this.isDomainSocket) {\n    return cb(null, params.join(' '))\n  }\n  if (this.client_encoding) {\n    params.push('client_encoding=' + quoteParamValue(this.client_encoding))\n  }\n  dns.lookup(this.host, function (err, address) {\n    if (err) return cb(err, null)\n    params.push('hostaddr=' + quoteParamValue(address))\n    return cb(null, params.join(' '))\n  })\n}\n\nmodule.exports = ConnectionParameters\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\nvar Writer = require('buffer-writer')\nvar Reader = require('packet-reader')\n\nvar TEXT_MODE = 0\nvar BINARY_MODE = 1\nvar Connection = function (config) {\n  EventEmitter.call(this)\n  config = config || {}\n  this.stream = config.stream || new net.Socket()\n  this._keepAlive = config.keepAlive\n  this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n  this.lastBuffer = false\n  this.lastOffset = 0\n  this.buffer = null\n  this.offset = null\n  this.encoding = config.encoding || 'utf8'\n  this.parsedStatements = {}\n  this.writer = new Writer()\n  this.ssl = config.ssl || false\n  this._ending = false\n  this._mode = TEXT_MODE\n  this._emitMessage = false\n  this._reader = new Reader({\n    headerSize: 1,\n    lengthPadding: -4\n  })\n  var self = this\n  this.on('newListener', function (eventName) {\n    if (eventName === 'message') {\n      self._emitMessage = true\n    }\n  })\n}\n\nutil.inherits(Connection, EventEmitter)\n\nConnection.prototype.connect = function (port, host) {\n  var self = this\n\n  if (this.stream.readyState === 'closed') {\n    this.stream.connect(port, host)\n  } else if (this.stream.readyState === 'open') {\n    this.emit('connect')\n  }\n\n  this.stream.on('connect', function () {\n    if (self._keepAlive) {\n      self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n    }\n    self.emit('connect')\n  })\n\n  const reportStreamError = function (error) {\n    // don't raise ECONNRESET errors - they can & should be ignored\n    // during disconnect\n    if (self._ending && error.code === 'ECONNRESET') {\n      return\n    }\n    self.emit('error', error)\n  }\n  this.stream.on('error', reportStreamError)\n\n  this.stream.on('close', function () {\n    self.emit('end')\n  })\n\n  if (!this.ssl) {\n    return this.attachListeners(this.stream)\n  }\n\n  this.stream.once('data', function (buffer) {\n    var responseCode = buffer.toString('utf8')\n    switch (responseCode) {\n      case 'N': // Server does not support SSL connections\n        return self.emit('error', new Error('The server does not support SSL connections'))\n      case 'S': // Server supports SSL connections, continue with a secure connection\n        break\n      default: // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n        return self.emit('error', new Error('There was an error establishing an SSL connection'))\n    }\n    var tls = require('tls')\n    self.stream = tls.connect({\n      socket: self.stream,\n      servername: host,\n      checkServerIdentity: self.ssl.checkServerIdentity || tls.checkServerIdentity,\n      rejectUnauthorized: self.ssl.rejectUnauthorized,\n      ca: self.ssl.ca,\n      pfx: self.ssl.pfx,\n      key: self.ssl.key,\n      passphrase: self.ssl.passphrase,\n      cert: self.ssl.cert,\n      secureOptions: self.ssl.secureOptions,\n      NPNProtocols: self.ssl.NPNProtocols\n    })\n    self.attachListeners(self.stream)\n    self.stream.on('error', reportStreamError)\n\n    self.emit('sslconnect')\n  })\n}\n\nConnection.prototype.attachListeners = function (stream) {\n  var self = this\n  stream.on('data', function (buff) {\n    self._reader.addChunk(buff)\n    var packet = self._reader.read()\n    while (packet) {\n      var msg = self.parseMessage(packet)\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (self._emitMessage) {\n        self.emit('message', msg)\n      }\n      self.emit(eventName, msg)\n      packet = self._reader.read()\n    }\n  })\n  stream.on('end', function () {\n    self.emit('end')\n  })\n}\n\nConnection.prototype.requestSsl = function () {\n  var bodyBuffer = this.writer\n    .addInt16(0x04D2)\n    .addInt16(0x162F).flush()\n\n  var length = bodyBuffer.length + 4\n\n  var buffer = new Writer()\n    .addInt32(length)\n    .add(bodyBuffer)\n    .join()\n  this.stream.write(buffer)\n}\n\nConnection.prototype.startup = function (config) {\n  var writer = this.writer\n    .addInt16(3)\n    .addInt16(0)\n\n  Object.keys(config).forEach(function (key) {\n    var val = config[key]\n    writer.addCString(key).addCString(val)\n  })\n\n  writer.addCString('client_encoding').addCString(\"'utf-8'\")\n\n  var bodyBuffer = writer.addCString('').flush()\n  // this message is sent without a code\n\n  var length = bodyBuffer.length + 4\n\n  var buffer = new Writer()\n    .addInt32(length)\n    .add(bodyBuffer)\n    .join()\n  this.stream.write(buffer)\n}\n\nConnection.prototype.cancel = function (processID, secretKey) {\n  var bodyBuffer = this.writer\n    .addInt16(1234)\n    .addInt16(5678)\n    .addInt32(processID)\n    .addInt32(secretKey)\n    .flush()\n\n  var length = bodyBuffer.length + 4\n\n  var buffer = new Writer()\n    .addInt32(length)\n    .add(bodyBuffer)\n    .join()\n  this.stream.write(buffer)\n}\n\nConnection.prototype.password = function (password) {\n  // 0x70 = 'p'\n  this._send(0x70, this.writer.addCString(password))\n}\n\nConnection.prototype.sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  // 0x70 = 'p'\n  this.writer\n    .addCString(mechanism)\n    .addInt32(Buffer.byteLength(initialResponse))\n    .addString(initialResponse)\n\n  this._send(0x70)\n}\n\nConnection.prototype.sendSCRAMClientFinalMessage = function (additionalData) {\n  // 0x70 = 'p'\n  this.writer\n    .addString(additionalData)\n\n  this._send(0x70)\n}\n\nConnection.prototype._send = function (code, more) {\n  if (!this.stream.writable) {\n    return false\n  }\n  if (more === true) {\n    this.writer.addHeader(code)\n  } else {\n    return this.stream.write(this.writer.flush(code))\n  }\n}\n\nConnection.prototype.query = function (text) {\n  // 0x51 = Q\n  this.stream.write(this.writer.addCString(text).flush(0x51))\n}\n\n// send parse message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.parse = function (query, more) {\n  // expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n\n  // normalize missing query names to allow for null\n  query.name = query.name || ''\n  if (query.name.length > 63) {\n    /* eslint-disable no-console */\n    console.error('Warning! Postgres only supports 63 characters for query names.')\n    console.error('You supplied %s (%s)', query.name, query.name.length)\n    console.error('This can cause conflicts and silent errors executing queries')\n    /* eslint-enable no-console */\n  }\n  // normalize null type array\n  query.types = query.types || []\n  var len = query.types.length\n  var buffer = this.writer\n    .addCString(query.name) // name of query\n    .addCString(query.text) // actual query text\n    .addInt16(len)\n  for (var i = 0; i < len; i++) {\n    buffer.addInt32(query.types[i])\n  }\n\n  var code = 0x50\n  this._send(code, more)\n}\n\n// send bind message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.bind = function (config, more) {\n  // normalize config\n  config = config || {}\n  config.portal = config.portal || ''\n  config.statement = config.statement || ''\n  config.binary = config.binary || false\n  var values = config.values || []\n  var len = values.length\n  var useBinary = false\n  for (var j = 0; j < len; j++) { useBinary |= values[j] instanceof Buffer }\n  var buffer = this.writer\n    .addCString(config.portal)\n    .addCString(config.statement)\n  if (!useBinary) { buffer.addInt16(0) } else {\n    buffer.addInt16(len)\n    for (j = 0; j < len; j++) { buffer.addInt16(values[j] instanceof Buffer) }\n  }\n  buffer.addInt16(len)\n  for (var i = 0; i < len; i++) {\n    var val = values[i]\n    if (val === null || typeof val === 'undefined') {\n      buffer.addInt32(-1)\n    } else if (val instanceof Buffer) {\n      buffer.addInt32(val.length)\n      buffer.add(val)\n    } else {\n      buffer.addInt32(Buffer.byteLength(val))\n      buffer.addString(val)\n    }\n  }\n\n  if (config.binary) {\n    buffer.addInt16(1) // format codes to use binary\n    buffer.addInt16(1)\n  } else {\n    buffer.addInt16(0) // format codes to use text\n  }\n  // 0x42 = 'B'\n  this._send(0x42, more)\n}\n\n// send execute message\n// \"more\" === true to buffer the message until flush() is called\nConnection.prototype.execute = function (config, more) {\n  config = config || {}\n  config.portal = config.portal || ''\n  config.rows = config.rows || ''\n  this.writer\n    .addCString(config.portal)\n    .addInt32(config.rows)\n\n  // 0x45 = 'E'\n  this._send(0x45, more)\n}\n\nvar emptyBuffer = Buffer.alloc(0)\n\nConnection.prototype.flush = function () {\n  // 0x48 = 'H'\n  this.writer.add(emptyBuffer)\n  this._send(0x48)\n}\n\nConnection.prototype.sync = function () {\n  // clear out any pending data in the writer\n  this.writer.flush(0)\n\n  this.writer.add(emptyBuffer)\n  this._ending = true\n  this._send(0x53)\n}\n\nconst END_BUFFER = Buffer.from([0x58, 0x00, 0x00, 0x00, 0x04])\n\nConnection.prototype.end = function () {\n  // 0x58 = 'X'\n  this.writer.add(emptyBuffer)\n  this._ending = true\n  return this.stream.write(END_BUFFER, () => {\n    this.stream.end()\n  })\n}\n\nConnection.prototype.close = function (msg, more) {\n  this.writer.addCString(msg.type + (msg.name || ''))\n  this._send(0x43, more)\n}\n\nConnection.prototype.describe = function (msg, more) {\n  this.writer.addCString(msg.type + (msg.name || ''))\n  this._send(0x44, more)\n}\n\nConnection.prototype.sendCopyFromChunk = function (chunk) {\n  this.stream.write(this.writer.add(chunk).flush(0x64))\n}\n\nConnection.prototype.endCopyFrom = function () {\n  this.stream.write(this.writer.add(emptyBuffer).flush(0x63))\n}\n\nConnection.prototype.sendCopyFail = function (msg) {\n  // this.stream.write(this.writer.add(emptyBuffer).flush(0x66));\n  this.writer.addCString(msg)\n  this._send(0x66)\n}\n\nvar Message = function (name, length) {\n  this.name = name\n  this.length = length\n}\n\nConnection.prototype.parseMessage = function (buffer) {\n  this.offset = 0\n  var length = buffer.length + 4\n  switch (this._reader.header) {\n    case 0x52: // R\n      return this.parseR(buffer, length)\n\n    case 0x53: // S\n      return this.parseS(buffer, length)\n\n    case 0x4b: // K\n      return this.parseK(buffer, length)\n\n    case 0x43: // C\n      return this.parseC(buffer, length)\n\n    case 0x5a: // Z\n      return this.parseZ(buffer, length)\n\n    case 0x54: // T\n      return this.parseT(buffer, length)\n\n    case 0x44: // D\n      return this.parseD(buffer, length)\n\n    case 0x45: // E\n      return this.parseE(buffer, length)\n\n    case 0x4e: // N\n      return this.parseN(buffer, length)\n\n    case 0x31: // 1\n      return new Message('parseComplete', length)\n\n    case 0x32: // 2\n      return new Message('bindComplete', length)\n\n    case 0x33: // 3\n      return new Message('closeComplete', length)\n\n    case 0x41: // A\n      return this.parseA(buffer, length)\n\n    case 0x6e: // n\n      return new Message('noData', length)\n\n    case 0x49: // I\n      return new Message('emptyQuery', length)\n\n    case 0x73: // s\n      return new Message('portalSuspended', length)\n\n    case 0x47: // G\n      return this.parseG(buffer, length)\n\n    case 0x48: // H\n      return this.parseH(buffer, length)\n\n    case 0x57: // W\n      return new Message('replicationStart', length)\n\n    case 0x63: // c\n      return new Message('copyDone', length)\n\n    case 0x64: // d\n      return this.parsed(buffer, length)\n  }\n}\n\nConnection.prototype.parseR = function (buffer, length) {\n  var code = this.parseInt32(buffer)\n\n  var msg = new Message('authenticationOk', length)\n\n  switch (code) {\n    case 0: // AuthenticationOk\n      return msg\n    case 3: // AuthenticationCleartextPassword\n      if (msg.length === 8) {\n        msg.name = 'authenticationCleartextPassword'\n        return msg\n      }\n      break\n    case 5: // AuthenticationMD5Password\n      if (msg.length === 12) {\n        msg.name = 'authenticationMD5Password'\n        msg.salt = Buffer.alloc(4)\n        buffer.copy(msg.salt, 0, this.offset, this.offset + 4)\n        this.offset += 4\n        return msg\n      }\n\n      break\n    case 10: // AuthenticationSASL\n      msg.name = 'authenticationSASL'\n      msg.mechanisms = []\n      do {\n        var mechanism = this.parseCString(buffer)\n\n        if (mechanism) {\n          msg.mechanisms.push(mechanism)\n        }\n      } while (mechanism)\n\n      return msg\n    case 11: // AuthenticationSASLContinue\n      msg.name = 'authenticationSASLContinue'\n      msg.data = this.readString(buffer, length - 4)\n\n      return msg\n    case 12: // AuthenticationSASLFinal\n      msg.name = 'authenticationSASLFinal'\n      msg.data = this.readString(buffer, length - 4)\n\n      return msg\n  }\n\n  throw new Error('Unknown authenticationOk message type' + util.inspect(msg))\n}\n\nConnection.prototype.parseS = function (buffer, length) {\n  var msg = new Message('parameterStatus', length)\n  msg.parameterName = this.parseCString(buffer)\n  msg.parameterValue = this.parseCString(buffer)\n  return msg\n}\n\nConnection.prototype.parseK = function (buffer, length) {\n  var msg = new Message('backendKeyData', length)\n  msg.processID = this.parseInt32(buffer)\n  msg.secretKey = this.parseInt32(buffer)\n  return msg\n}\n\nConnection.prototype.parseC = function (buffer, length) {\n  var msg = new Message('commandComplete', length)\n  msg.text = this.parseCString(buffer)\n  return msg\n}\n\nConnection.prototype.parseZ = function (buffer, length) {\n  var msg = new Message('readyForQuery', length)\n  msg.name = 'readyForQuery'\n  msg.status = this.readString(buffer, 1)\n  return msg\n}\n\nvar ROW_DESCRIPTION = 'rowDescription'\nConnection.prototype.parseT = function (buffer, length) {\n  var msg = new Message(ROW_DESCRIPTION, length)\n  msg.fieldCount = this.parseInt16(buffer)\n  var fields = []\n  for (var i = 0; i < msg.fieldCount; i++) {\n    fields.push(this.parseField(buffer))\n  }\n  msg.fields = fields\n  return msg\n}\n\nvar Field = function () {\n  this.name = null\n  this.tableID = null\n  this.columnID = null\n  this.dataTypeID = null\n  this.dataTypeSize = null\n  this.dataTypeModifier = null\n  this.format = null\n}\n\nvar FORMAT_TEXT = 'text'\nvar FORMAT_BINARY = 'binary'\nConnection.prototype.parseField = function (buffer) {\n  var field = new Field()\n  field.name = this.parseCString(buffer)\n  field.tableID = this.parseInt32(buffer)\n  field.columnID = this.parseInt16(buffer)\n  field.dataTypeID = this.parseInt32(buffer)\n  field.dataTypeSize = this.parseInt16(buffer)\n  field.dataTypeModifier = this.parseInt32(buffer)\n  if (this.parseInt16(buffer) === TEXT_MODE) {\n    this._mode = TEXT_MODE\n    field.format = FORMAT_TEXT\n  } else {\n    this._mode = BINARY_MODE\n    field.format = FORMAT_BINARY\n  }\n  return field\n}\n\nvar DATA_ROW = 'dataRow'\nvar DataRowMessage = function (length, fieldCount) {\n  this.name = DATA_ROW\n  this.length = length\n  this.fieldCount = fieldCount\n  this.fields = []\n}\n\n// extremely hot-path code\nConnection.prototype.parseD = function (buffer, length) {\n  var fieldCount = this.parseInt16(buffer)\n  var msg = new DataRowMessage(length, fieldCount)\n  for (var i = 0; i < fieldCount; i++) {\n    msg.fields.push(this._readValue(buffer))\n  }\n  return msg\n}\n\n// extremely hot-path code\nConnection.prototype._readValue = function (buffer) {\n  var length = this.parseInt32(buffer)\n  if (length === -1) return null\n  if (this._mode === TEXT_MODE) {\n    return this.readString(buffer, length)\n  }\n  return this.readBytes(buffer, length)\n}\n\n// parses error\nConnection.prototype.parseE = function (buffer, length) {\n  var fields = {}\n  var msg, item\n  var input = new Message('error', length)\n  var fieldType = this.readString(buffer, 1)\n  while (fieldType !== '\\0') {\n    fields[fieldType] = this.parseCString(buffer)\n    fieldType = this.readString(buffer, 1)\n  }\n  if (input.name === 'error') {\n    // the msg is an Error instance\n    msg = new Error(fields.M)\n    for (item in input) {\n      // copy input properties to the error\n      if (Object.prototype.hasOwnProperty.call(input, item)) {\n        msg[item] = input[item]\n      }\n    }\n  } else {\n    // the msg is an object literal\n    msg = input\n    msg.message = fields.M\n  }\n  msg.severity = fields.S\n  msg.code = fields.C\n  msg.detail = fields.D\n  msg.hint = fields.H\n  msg.position = fields.P\n  msg.internalPosition = fields.p\n  msg.internalQuery = fields.q\n  msg.where = fields.W\n  msg.schema = fields.s\n  msg.table = fields.t\n  msg.column = fields.c\n  msg.dataType = fields.d\n  msg.constraint = fields.n\n  msg.file = fields.F\n  msg.line = fields.L\n  msg.routine = fields.R\n  return msg\n}\n\n// same thing, different name\nConnection.prototype.parseN = function (buffer, length) {\n  var msg = this.parseE(buffer, length)\n  msg.name = 'notice'\n  return msg\n}\n\nConnection.prototype.parseA = function (buffer, length) {\n  var msg = new Message('notification', length)\n  msg.processId = this.parseInt32(buffer)\n  msg.channel = this.parseCString(buffer)\n  msg.payload = this.parseCString(buffer)\n  return msg\n}\n\nConnection.prototype.parseG = function (buffer, length) {\n  var msg = new Message('copyInResponse', length)\n  return this.parseGH(buffer, msg)\n}\n\nConnection.prototype.parseH = function (buffer, length) {\n  var msg = new Message('copyOutResponse', length)\n  return this.parseGH(buffer, msg)\n}\n\nConnection.prototype.parseGH = function (buffer, msg) {\n  var isBinary = buffer[this.offset] !== 0\n  this.offset++\n  msg.binary = isBinary\n  var columnCount = this.parseInt16(buffer)\n  msg.columnTypes = []\n  for (var i = 0; i < columnCount; i++) {\n    msg.columnTypes.push(this.parseInt16(buffer))\n  }\n  return msg\n}\n\nConnection.prototype.parsed = function (buffer, length) {\n  var msg = new Message('copyData', length)\n  msg.chunk = this.readBytes(buffer, msg.length - 4)\n  return msg\n}\n\nConnection.prototype.parseInt32 = function (buffer) {\n  var value = buffer.readInt32BE(this.offset)\n  this.offset += 4\n  return value\n}\n\nConnection.prototype.parseInt16 = function (buffer) {\n  var value = buffer.readInt16BE(this.offset)\n  this.offset += 2\n  return value\n}\n\nConnection.prototype.readString = function (buffer, length) {\n  return buffer.toString(this.encoding, this.offset, (this.offset += length))\n}\n\nConnection.prototype.readBytes = function (buffer, length) {\n  return buffer.slice(this.offset, (this.offset += length))\n}\n\nConnection.prototype.parseCString = function (buffer) {\n  var start = this.offset\n  var end = buffer.indexOf(0, start)\n  this.offset = end + 1\n  return buffer.toString(this.encoding, start, end)\n}\n// end parsing methods\nmodule.exports = Connection\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  // database host. defaults to localhost\n  host: 'localhost',\n\n  // database user's name\n  user: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,\n\n  // name of database to connect\n  database: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,\n\n  // database user's password\n  password: null,\n\n  // a Postgres connection string to be used instead of setting individual connection items\n  // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined\n  // in the defaults object.\n  connectionString: undefined,\n\n  // database port\n  port: 5432,\n\n  // number of rows to return at a time from a prepared statement's\n  // portal. 0 will return all rows at once\n  rows: 0,\n\n  // binary result mode\n  binary: false,\n\n  // Connection pool options - see https://github.com/brianc/node-pg-pool\n\n  // number of connections to use in connection pool\n  // 0 will disable connection pooling\n  max: 10,\n\n  // max milliseconds a client can go unused before it is removed\n  // from the pool and destroyed\n  idleTimeoutMillis: 30000,\n\n  client_encoding: '',\n\n  ssl: false,\n\n  application_name: undefined,\n\n  fallback_application_name: undefined,\n\n  parseInputDatesAsUTC: false,\n\n  // max milliseconds any query using this connection will execute for before timing out in error.\n  // false=unlimited\n  statement_timeout: false,\n\n  // max milliseconds to wait for query to complete (client side)\n  query_timeout: false,\n\n  connect_timeout: 0,\n\n  keepalives: 1,\n\n  keepalives_idle: 0\n}\n\nvar pgTypes = require('pg-types')\n// save default parsers\nvar parseBigInteger = pgTypes.getTypeParser(20, 'text')\nvar parseBigIntegerArray = pgTypes.getTypeParser(1016, 'text')\n\n// parse int8 so you can get your count values as actual numbers\nmodule.exports.__defineSetter__('parseInt8', function (val) {\n  pgTypes.setTypeParser(20, 'text', val ? pgTypes.getTypeParser(23, 'text') : parseBigInteger)\n  pgTypes.setTypeParser(1016, 'text', val ? pgTypes.getTypeParser(1007, 'text') : parseBigIntegerArray)\n})\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar util = require('util')\nvar Client = require('./client')\nvar defaults = require('./defaults')\nvar Connection = require('./connection')\nvar Pool = require('pg-pool')\n\nconst poolFactory = (Client) => {\n  var BoundPool = function (options) {\n    var config = Object.assign({ Client: Client }, options)\n    return new Pool(config)\n  }\n\n  util.inherits(BoundPool, Pool)\n\n  return BoundPool\n}\n\nvar PG = function (clientConstructor) {\n  this.defaults = defaults\n  this.Client = clientConstructor\n  this.Query = this.Client.Query\n  this.Pool = poolFactory(this.Client)\n  this._pools = []\n  this.Connection = Connection\n  this.types = require('pg-types')\n}\n\nif (typeof process.env.NODE_PG_FORCE_NATIVE !== 'undefined') {\n  module.exports = new PG(require('./native'))\n} else {\n  module.exports = new PG(Client)\n\n  // lazy require native module...the native module may not have installed\n  module.exports.__defineGetter__('native', function () {\n    delete module.exports.native\n    var native = null\n    try {\n      native = new PG(require('./native'))\n    } catch (err) {\n      if (err.code !== 'MODULE_NOT_FOUND') {\n        throw err\n      }\n      /* eslint-disable no-console */\n      console.error(err.message)\n      /* eslint-enable no-console */\n    }\n    module.exports.native = native\n    return native\n  })\n}\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\n// eslint-disable-next-line\nvar Native = require('pg-native')\nvar TypeOverrides = require('../type-overrides')\nvar semver = require('semver')\nvar pkg = require('../../package.json')\nvar assert = require('assert')\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar ConnectionParameters = require('../connection-parameters')\n\nvar msg = 'Version >= ' + pkg.minNativeVersion + ' of pg-native required.'\nassert(semver.gte(Native.version, pkg.minNativeVersion), msg)\n\nvar NativeQuery = require('./query')\n\nvar Client = module.exports = function (config) {\n  EventEmitter.call(this)\n  config = config || {}\n\n  this._Promise = config.Promise || global.Promise\n  this._types = new TypeOverrides(config.types)\n\n  this.native = new Native({\n    types: this._types\n  })\n\n  this._queryQueue = []\n  this._ending = false\n  this._connecting = false\n  this._connected = false\n  this._queryable = true\n\n  // keep these on the object for legacy reasons\n  // for the time being. TODO: deprecate all this jazz\n  var cp = this.connectionParameters = new ConnectionParameters(config)\n  this.user = cp.user\n  this.password = cp.password\n  this.database = cp.database\n  this.host = cp.host\n  this.port = cp.port\n\n  // a hash to hold named queries\n  this.namedQueries = {}\n}\n\nClient.Query = NativeQuery\n\nutil.inherits(Client, EventEmitter)\n\nClient.prototype._errorAllQueries = function (err) {\n  const enqueueError = (query) => {\n    process.nextTick(() => {\n      query.native = this.native\n      query.handleError(err)\n    })\n  }\n\n  if (this._hasActiveQuery()) {\n    enqueueError(this._activeQuery)\n    this._activeQuery = null\n  }\n\n  this._queryQueue.forEach(enqueueError)\n  this._queryQueue.length = 0\n}\n\n// connect to the backend\n// pass an optional callback to be called once connected\n// or with an error if there was a connection error\nClient.prototype._connect = function (cb) {\n  var self = this\n\n  if (this._connecting) {\n    process.nextTick(() => cb(new Error('Client has already been connected. You cannot reuse a client.')))\n    return\n  }\n\n  this._connecting = true\n\n  this.connectionParameters.getLibpqConnectionString(function (err, conString) {\n    if (err) return cb(err)\n    self.native.connect(conString, function (err) {\n      if (err) return cb(err)\n\n      // set internal states to connected\n      self._connected = true\n\n      // handle connection errors from the native layer\n      self.native.on('error', function (err) {\n        self._queryable = false\n        self._errorAllQueries(err)\n        self.emit('error', err)\n      })\n\n      self.native.on('notification', function (msg) {\n        self.emit('notification', {\n          channel: msg.relname,\n          payload: msg.extra\n        })\n      })\n\n      // signal we are connected now\n      self.emit('connect')\n      self._pulseQueryQueue(true)\n\n      cb()\n    })\n  })\n}\n\nClient.prototype.connect = function (callback) {\n  if (callback) {\n    this._connect(callback)\n    return\n  }\n\n  return new this._Promise((resolve, reject) => {\n    this._connect((error) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\n// send a query to the server\n// this method is highly overloaded to take\n// 1) string query, optional array of parameters, optional function callback\n// 2) object query with {\n//    string query\n//    optional array values,\n//    optional function callback instead of as a separate parameter\n//    optional string name to name & cache the query plan\n//    optional string rowMode = 'array' for an array of results\n//  }\nClient.prototype.query = function (config, values, callback) {\n  var query\n  var result\n  var readTimeout\n  var readTimeoutTimer\n  var queryCallback\n\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query')\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n    result = query = config\n    // accept query(new Query(...), (err, res) => { }) style\n    if (typeof values === 'function') {\n      config.callback = values\n    }\n  } else {\n    readTimeout = this.connectionParameters.query_timeout\n    query = new NativeQuery(config, values, callback)\n    if (!query.callback) {\n      let resolveOut, rejectOut\n      result = new this._Promise((resolve, reject) => {\n        resolveOut = resolve\n        rejectOut = reject\n      })\n      query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res)\n    }\n  }\n\n  if (readTimeout) {\n    queryCallback = query.callback\n\n    readTimeoutTimer = setTimeout(() => {\n      var error = new Error('Query read timeout')\n\n      process.nextTick(() => {\n        query.handleError(error, this.connection)\n      })\n\n      queryCallback(error)\n\n      // we already returned an error,\n      // just do nothing if query completes\n      query.callback = () => {}\n\n      // Remove from queue\n      var index = this._queryQueue.indexOf(query)\n      if (index > -1) {\n        this._queryQueue.splice(index, 1)\n      }\n\n      this._pulseQueryQueue()\n    }, readTimeout)\n\n    query.callback = (err, res) => {\n      clearTimeout(readTimeoutTimer)\n      queryCallback(err, res)\n    }\n  }\n\n  if (!this._queryable) {\n    query.native = this.native\n    process.nextTick(() => {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'))\n    })\n    return result\n  }\n\n  if (this._ending) {\n    query.native = this.native\n    process.nextTick(() => {\n      query.handleError(new Error('Client was closed and is not queryable'))\n    })\n    return result\n  }\n\n  this._queryQueue.push(query)\n  this._pulseQueryQueue()\n  return result\n}\n\n// disconnect from the backend server\nClient.prototype.end = function (cb) {\n  var self = this\n\n  this._ending = true\n\n  if (!this._connected) {\n    this.once('connect', this.end.bind(this, cb))\n  }\n  var result\n  if (!cb) {\n    result = new this._Promise(function (resolve, reject) {\n      cb = (err) => err ? reject(err) : resolve()\n    })\n  }\n  this.native.end(function () {\n    self._errorAllQueries(new Error('Connection terminated'))\n\n    process.nextTick(() => {\n      self.emit('end')\n      if (cb) cb()\n    })\n  })\n  return result\n}\n\nClient.prototype._hasActiveQuery = function () {\n  return this._activeQuery && this._activeQuery.state !== 'error' && this._activeQuery.state !== 'end'\n}\n\nClient.prototype._pulseQueryQueue = function (initialConnection) {\n  if (!this._connected) {\n    return\n  }\n  if (this._hasActiveQuery()) {\n    return\n  }\n  var query = this._queryQueue.shift()\n  if (!query) {\n    if (!initialConnection) {\n      this.emit('drain')\n    }\n    return\n  }\n  this._activeQuery = query\n  query.submit(this)\n  var self = this\n  query.once('_done', function () {\n    self._pulseQueryQueue()\n  })\n}\n\n// attempt to cancel an in-progress query\nClient.prototype.cancel = function (query) {\n  if (this._activeQuery === query) {\n    this.native.cancel(function () {})\n  } else if (this._queryQueue.indexOf(query) !== -1) {\n    this._queryQueue.splice(this._queryQueue.indexOf(query), 1)\n  }\n}\n\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn)\n}\n\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format)\n}\n","'use strict'\nmodule.exports = require('./client')\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar utils = require('../utils')\n\nvar NativeQuery = module.exports = function (config, values, callback) {\n  EventEmitter.call(this)\n  config = utils.normalizeQueryConfig(config, values, callback)\n  this.text = config.text\n  this.values = config.values\n  this.name = config.name\n  this.callback = config.callback\n  this.state = 'new'\n  this._arrayMode = config.rowMode === 'array'\n\n  // if the 'row' event is listened for\n  // then emit them as they come in\n  // without setting singleRowMode to true\n  // this has almost no meaning because libpq\n  // reads all rows into memory befor returning any\n  this._emitRowEvents = false\n  this.on('newListener', function (event) {\n    if (event === 'row') this._emitRowEvents = true\n  }.bind(this))\n}\n\nutil.inherits(NativeQuery, EventEmitter)\n\nvar errorFieldMap = {\n  /* eslint-disable quote-props */\n  'sqlState': 'code',\n  'statementPosition': 'position',\n  'messagePrimary': 'message',\n  'context': 'where',\n  'schemaName': 'schema',\n  'tableName': 'table',\n  'columnName': 'column',\n  'dataTypeName': 'dataType',\n  'constraintName': 'constraint',\n  'sourceFile': 'file',\n  'sourceLine': 'line',\n  'sourceFunction': 'routine'\n}\n\nNativeQuery.prototype.handleError = function (err) {\n  // copy pq error fields into the error object\n  var fields = this.native.pq.resultErrorFields()\n  if (fields) {\n    for (var key in fields) {\n      var normalizedFieldName = errorFieldMap[key] || key\n      err[normalizedFieldName] = fields[key]\n    }\n  }\n  if (this.callback) {\n    this.callback(err)\n  } else {\n    this.emit('error', err)\n  }\n  this.state = 'error'\n}\n\nNativeQuery.prototype.then = function (onSuccess, onFailure) {\n  return this._getPromise().then(onSuccess, onFailure)\n}\n\nNativeQuery.prototype.catch = function (callback) {\n  return this._getPromise().catch(callback)\n}\n\nNativeQuery.prototype._getPromise = function () {\n  if (this._promise) return this._promise\n  this._promise = new Promise(function (resolve, reject) {\n    this._once('end', resolve)\n    this._once('error', reject)\n  }.bind(this))\n  return this._promise\n}\n\nNativeQuery.prototype.submit = function (client) {\n  this.state = 'running'\n  var self = this\n  this.native = client.native\n  client.native.arrayMode = this._arrayMode\n\n  var after = function (err, rows, results) {\n    client.native.arrayMode = false\n    setImmediate(function () {\n      self.emit('_done')\n    })\n\n    // handle possible query error\n    if (err) {\n      return self.handleError(err)\n    }\n\n    // emit row events for each row in the result\n    if (self._emitRowEvents) {\n      if (results.length > 1) {\n        rows.forEach((rowOfRows, i) => {\n          rowOfRows.forEach(row => {\n            self.emit('row', row, results[i])\n          })\n        })\n      } else {\n        rows.forEach(function (row) {\n          self.emit('row', row, results)\n        })\n      }\n    }\n\n    // handle successful result\n    self.state = 'end'\n    self.emit('end', results)\n    if (self.callback) {\n      self.callback(null, results)\n    }\n  }\n\n  if (process.domain) {\n    after = process.domain.bind(after)\n  }\n\n  // named query\n  if (this.name) {\n    if (this.name.length > 63) {\n      /* eslint-disable no-console */\n      console.error('Warning! Postgres only supports 63 characters for query names.')\n      console.error('You supplied %s (%s)', this.name, this.name.length)\n      console.error('This can cause conflicts and silent errors executing queries')\n      /* eslint-enable no-console */\n    }\n    var values = (this.values || []).map(utils.prepareValue)\n\n    // check if the client has already executed this named query\n    // if so...just execute it again - skip the planning phase\n    if (client.namedQueries[this.name]) {\n      if (this.text && client.namedQueries[this.name] !== this.text) {\n        const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n        return after(err)\n      }\n      return client.native.execute(this.name, values, after)\n    }\n    // plan the named query the first time, then execute it\n    return client.native.prepare(this.name, this.text, values.length, function (err) {\n      if (err) return after(err)\n      client.namedQueries[self.name] = self.text\n      return self.native.execute(self.name, values, after)\n    })\n  } else if (this.values) {\n    if (!Array.isArray(this.values)) {\n      const err = new Error('Query values must be an array')\n      return after(err)\n    }\n    var vals = this.values.map(utils.prepareValue)\n    client.native.query(this.text, vals, after)\n  } else {\n    client.native.query(this.text, after)\n  }\n}\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\nvar Result = require('./result')\nvar utils = require('./utils')\n\nvar Query = function (config, values, callback) {\n  // use of \"new\" optional\n  if (!(this instanceof Query)) { return new Query(config, values, callback) }\n\n  config = utils.normalizeQueryConfig(config, values, callback)\n\n  this.text = config.text\n  this.values = config.values\n  this.rows = config.rows\n  this.types = config.types\n  this.name = config.name\n  this.binary = config.binary\n  // use unique portal name each time\n  this.portal = config.portal || ''\n  this.callback = config.callback\n  this._rowMode = config.rowMode\n  if (process.domain && config.callback) {\n    this.callback = process.domain.bind(config.callback)\n  }\n  this._result = new Result(this._rowMode, this.types)\n\n  // potential for multiple results\n  this._results = this._result\n  this.isPreparedStatement = false\n  this._canceledDueToError = false\n  this._promise = null\n  EventEmitter.call(this)\n}\n\nutil.inherits(Query, EventEmitter)\n\nQuery.prototype.requiresPreparation = function () {\n  // named queries must always be prepared\n  if (this.name) { return true }\n  // always prepare if there are max number of rows expected per\n  // portal execution\n  if (this.rows) { return true }\n  // don't prepare empty text queries\n  if (!this.text) { return false }\n  // prepare if there are values\n  if (!this.values) { return false }\n  return this.values.length > 0\n}\n\nQuery.prototype._checkForMultirow = function () {\n  // if we already have a result with a command property\n  // then we've already executed one query in a multi-statement simple query\n  // turn our results into an array of results\n  if (this._result.command) {\n    if (!Array.isArray(this._results)) {\n      this._results = [this._result]\n    }\n    this._result = new Result(this._rowMode, this.types)\n    this._results.push(this._result)\n  }\n}\n\n// associates row metadata from the supplied\n// message with this query object\n// metadata used when parsing row results\nQuery.prototype.handleRowDescription = function (msg) {\n  this._checkForMultirow()\n  this._result.addFields(msg.fields)\n  this._accumulateRows = this.callback || !this.listeners('row').length\n}\n\nQuery.prototype.handleDataRow = function (msg) {\n  var row\n\n  if (this._canceledDueToError) {\n    return\n  }\n\n  try {\n    row = this._result.parseRow(msg.fields)\n  } catch (err) {\n    this._canceledDueToError = err\n    return\n  }\n\n  this.emit('row', row, this._result)\n  if (this._accumulateRows) {\n    this._result.addRow(row)\n  }\n}\n\nQuery.prototype.handleCommandComplete = function (msg, con) {\n  this._checkForMultirow()\n  this._result.addCommandComplete(msg)\n  // need to sync after each command complete of a prepared statement\n  if (this.isPreparedStatement) {\n    con.sync()\n  }\n}\n\n// if a named prepared statement is created with empty query text\n// the backend will send an emptyQuery message but *not* a command complete message\n// execution on the connection will hang until the backend receives a sync message\nQuery.prototype.handleEmptyQuery = function (con) {\n  if (this.isPreparedStatement) {\n    con.sync()\n  }\n}\n\nQuery.prototype.handleReadyForQuery = function (con) {\n  if (this._canceledDueToError) {\n    return this.handleError(this._canceledDueToError, con)\n  }\n  if (this.callback) {\n    this.callback(null, this._results)\n  }\n  this.emit('end', this._results)\n}\n\nQuery.prototype.handleError = function (err, connection) {\n  // need to sync after error during a prepared statement\n  if (this.isPreparedStatement) {\n    connection.sync()\n  }\n  if (this._canceledDueToError) {\n    err = this._canceledDueToError\n    this._canceledDueToError = false\n  }\n  // if callback supplied do not emit error event as uncaught error\n  // events will bubble up to node process\n  if (this.callback) {\n    return this.callback(err)\n  }\n  this.emit('error', err)\n}\n\nQuery.prototype.submit = function (connection) {\n  if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n    return new Error('A query must have either text or a name. Supplying neither is unsupported.')\n  }\n  const previous = connection.parsedStatements[this.name]\n  if (this.text && previous && this.text !== previous) {\n    return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n  }\n  if (this.values && !Array.isArray(this.values)) {\n    return new Error('Query values must be an array')\n  }\n  if (this.requiresPreparation()) {\n    this.prepare(connection)\n  } else {\n    connection.query(this.text)\n  }\n  return null\n}\n\nQuery.prototype.hasBeenParsed = function (connection) {\n  return this.name && connection.parsedStatements[this.name]\n}\n\nQuery.prototype.handlePortalSuspended = function (connection) {\n  this._getRows(connection, this.rows)\n}\n\nQuery.prototype._getRows = function (connection, rows) {\n  connection.execute({\n    portal: this.portal,\n    rows: rows\n  }, true)\n  connection.flush()\n}\n\nQuery.prototype.prepare = function (connection) {\n  var self = this\n  // prepared statements need sync to be called after each command\n  // complete or when an error is encountered\n  this.isPreparedStatement = true\n  // TODO refactor this poor encapsulation\n  if (!this.hasBeenParsed(connection)) {\n    connection.parse({\n      text: self.text,\n      name: self.name,\n      types: self.types\n    }, true)\n  }\n\n  if (self.values) {\n    try {\n      self.values = self.values.map(utils.prepareValue)\n    } catch (err) {\n      this.handleError(err, connection)\n      return\n    }\n  }\n\n  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  connection.bind({\n    portal: self.portal,\n    statement: self.name,\n    values: self.values,\n    binary: self.binary\n  }, true)\n\n  connection.describe({\n    type: 'P',\n    name: self.portal || ''\n  }, true)\n\n  this._getRows(connection, this.rows)\n}\n\nQuery.prototype.handleCopyInResponse = function (connection) {\n  connection.sendCopyFail('No source stream defined')\n}\n\n// eslint-disable-next-line no-unused-vars\nQuery.prototype.handleCopyData = function (msg, connection) {\n  // noop\n}\nmodule.exports = Query\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar types = require('pg-types')\n\n// result object returned from query\n// in the 'end' event and also\n// passed as second argument to provided callback\nvar Result = function (rowMode, types) {\n  this.command = null\n  this.rowCount = null\n  this.oid = null\n  this.rows = []\n  this.fields = []\n  this._parsers = []\n  this._types = types\n  this.RowCtor = null\n  this.rowAsArray = rowMode === 'array'\n  if (this.rowAsArray) {\n    this.parseRow = this._parseRowAsArray\n  }\n}\n\nvar matchRegexp = /^([A-Za-z]+)(?: (\\d+))?(?: (\\d+))?/\n\n// adds a command complete message\nResult.prototype.addCommandComplete = function (msg) {\n  var match\n  if (msg.text) {\n    // pure javascript\n    match = matchRegexp.exec(msg.text)\n  } else {\n    // native bindings\n    match = matchRegexp.exec(msg.command)\n  }\n  if (match) {\n    this.command = match[1]\n    if (match[3]) {\n      // COMMMAND OID ROWS\n      this.oid = parseInt(match[2], 10)\n      this.rowCount = parseInt(match[3], 10)\n    } else if (match[2]) {\n      // COMMAND ROWS\n      this.rowCount = parseInt(match[2], 10)\n    }\n  }\n}\n\nResult.prototype._parseRowAsArray = function (rowData) {\n  var row = []\n  for (var i = 0, len = rowData.length; i < len; i++) {\n    var rawValue = rowData[i]\n    if (rawValue !== null) {\n      row.push(this._parsers[i](rawValue))\n    } else {\n      row.push(null)\n    }\n  }\n  return row\n}\n\nResult.prototype.parseRow = function (rowData) {\n  var row = {}\n  for (var i = 0, len = rowData.length; i < len; i++) {\n    var rawValue = rowData[i]\n    var field = this.fields[i].name\n    if (rawValue !== null) {\n      row[field] = this._parsers[i](rawValue)\n    } else {\n      row[field] = null\n    }\n  }\n  return row\n}\n\nResult.prototype.addRow = function (row) {\n  this.rows.push(row)\n}\n\nResult.prototype.addFields = function (fieldDescriptions) {\n  // clears field definitions\n  // multiple query statements in 1 action can result in multiple sets\n  // of rowDescriptions...eg: 'select NOW(); select 1::int;'\n  // you need to reset the fields\n  if (this.fields.length) {\n    this.fields = []\n    this._parsers = []\n  }\n  for (var i = 0; i < fieldDescriptions.length; i++) {\n    var desc = fieldDescriptions[i]\n    this.fields.push(desc)\n    var parser = (this._types || types).getTypeParser(desc.dataTypeID, desc.format || 'text')\n    this._parsers.push(parser)\n  }\n}\n\nmodule.exports = Result\n","'use strict'\nconst crypto = require('crypto')\n\nfunction startSession (mechanisms) {\n  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {\n    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported')\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64')\n\n  return {\n    mechanism: 'SCRAM-SHA-256',\n    clientNonce,\n    response: 'n,,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse'\n  }\n}\n\nfunction continueSession (session, password, serverData) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse')\n  }\n\n  const sv = extractVariablesFromFirstServerMessage(serverData)\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')\n  }\n\n  var saltBytes = Buffer.from(sv.salt, 'base64')\n\n  var saltedPassword = Hi(password, saltBytes, sv.iteration)\n\n  var clientKey = createHMAC(saltedPassword, 'Client Key')\n  var storedKey = crypto.createHash('sha256').update(clientKey).digest()\n\n  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce\n  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration\n\n  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce\n\n  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof\n\n  var clientSignature = createHMAC(storedKey, authMessage)\n  var clientProofBytes = xorBuffers(clientKey, clientSignature)\n  var clientProof = clientProofBytes.toString('base64')\n\n  var serverKey = createHMAC(saltedPassword, 'Server Key')\n  var serverSignatureBytes = createHMAC(serverKey, authMessage)\n\n  session.message = 'SASLResponse'\n  session.serverSignature = serverSignatureBytes.toString('base64')\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof\n}\n\nfunction finalizeSession (session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse')\n  }\n\n  var serverSignature\n\n  String(serverData).split(',').forEach(function (part) {\n    switch (part[0]) {\n      case 'v':\n        serverSignature = part.substr(2)\n        break\n    }\n  })\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')\n  }\n}\n\nfunction extractVariablesFromFirstServerMessage (data) {\n  var nonce, salt, iteration\n\n  String(data).split(',').forEach(function (part) {\n    switch (part[0]) {\n      case 'r':\n        nonce = part.substr(2)\n        break\n      case 's':\n        salt = part.substr(2)\n        break\n      case 'i':\n        iteration = parseInt(part.substr(2), 10)\n        break\n    }\n  })\n\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')\n  }\n\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')\n  }\n\n  if (!iteration) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')\n  }\n\n  return {\n    nonce,\n    salt,\n    iteration\n  }\n}\n\nfunction xorBuffers (a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a)\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b)\n  var res = []\n  if (a.length > b.length) {\n    for (var i = 0; i < b.length; i++) {\n      res.push(a[i] ^ b[i])\n    }\n  } else {\n    for (var j = 0; j < a.length; j++) {\n      res.push(a[j] ^ b[j])\n    }\n  }\n  return Buffer.from(res)\n}\n\nfunction createHMAC (key, msg) {\n  return crypto.createHmac('sha256', key).update(msg).digest()\n}\n\nfunction Hi (password, saltBytes, iterations) {\n  var ui1 = createHMAC(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]))\n  var ui = ui1\n  for (var i = 0; i < iterations - 1; i++) {\n    ui1 = createHMAC(password, ui1)\n    ui = xorBuffers(ui, ui1)\n  }\n\n  return ui\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession\n}\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nvar types = require('pg-types')\n\nfunction TypeOverrides (userTypes) {\n  this._types = userTypes || types\n  this.text = {}\n  this.binary = {}\n}\n\nTypeOverrides.prototype.getOverrides = function (format) {\n  switch (format) {\n    case 'text': return this.text\n    case 'binary': return this.binary\n    default: return {}\n  }\n}\n\nTypeOverrides.prototype.setTypeParser = function (oid, format, parseFn) {\n  if (typeof format === 'function') {\n    parseFn = format\n    format = 'text'\n  }\n  this.getOverrides(format)[oid] = parseFn\n}\n\nTypeOverrides.prototype.getTypeParser = function (oid, format) {\n  format = format || 'text'\n  return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format)\n}\n\nmodule.exports = TypeOverrides\n","'use strict'\n/**\n * Copyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * README.md file in the root directory of this source tree.\n */\n\nconst crypto = require('crypto')\n\nconst defaults = require('./defaults')\n\nfunction escapeElement (elementRepresentation) {\n  var escaped = elementRepresentation\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\"/g, '\\\\\"')\n\n  return '\"' + escaped + '\"'\n}\n\n// convert a JS array to a postgres array literal\n// uses comma separator so won't work for types like box that use\n// a different array separator.\nfunction arrayString (val) {\n  var result = '{'\n  for (var i = 0; i < val.length; i++) {\n    if (i > 0) {\n      result = result + ','\n    }\n    if (val[i] === null || typeof val[i] === 'undefined') {\n      result = result + 'NULL'\n    } else if (Array.isArray(val[i])) {\n      result = result + arrayString(val[i])\n    } else if (val[i] instanceof Buffer) {\n      result += '\\\\\\\\x' + val[i].toString('hex')\n    } else {\n      result += escapeElement(prepareValue(val[i]))\n    }\n  }\n  result = result + '}'\n  return result\n}\n\n// converts values from javascript types\n// to their 'raw' counterparts for use as a postgres parameter\n// note: you can override this function to provide your own conversion mechanism\n// for complex types, etc...\nvar prepareValue = function (val, seen) {\n  if (val instanceof Buffer) {\n    return val\n  }\n  if (ArrayBuffer.isView(val)) {\n    var buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength)\n    if (buf.length === val.byteLength) {\n      return buf\n    }\n    return buf.slice(val.byteOffset, val.byteOffset + val.byteLength) // Node.js v4 does not support those Buffer.from params\n  }\n  if (val instanceof Date) {\n    if (defaults.parseInputDatesAsUTC) {\n      return dateToStringUTC(val)\n    } else {\n      return dateToString(val)\n    }\n  }\n  if (Array.isArray(val)) {\n    return arrayString(val)\n  }\n  if (val === null || typeof val === 'undefined') {\n    return null\n  }\n  if (typeof val === 'object') {\n    return prepareObject(val, seen)\n  }\n  return val.toString()\n}\n\nfunction prepareObject (val, seen) {\n  if (val && typeof val.toPostgres === 'function') {\n    seen = seen || []\n    if (seen.indexOf(val) !== -1) {\n      throw new Error('circular reference detected while preparing \"' + val + '\" for query')\n    }\n    seen.push(val)\n\n    return prepareValue(val.toPostgres(prepareValue), seen)\n  }\n  return JSON.stringify(val)\n}\n\nfunction pad (number, digits) {\n  number = '' + number\n  while (number.length < digits) { number = '0' + number }\n  return number\n}\n\nfunction dateToString (date) {\n  var offset = -date.getTimezoneOffset()\n\n  var year = date.getFullYear()\n  var isBCYear = year < 1\n  if (isBCYear) year = Math.abs(year) + 1 // negative years are 1 off their BC representation\n\n  var ret = pad(year, 4) + '-' +\n    pad(date.getMonth() + 1, 2) + '-' +\n    pad(date.getDate(), 2) + 'T' +\n    pad(date.getHours(), 2) + ':' +\n    pad(date.getMinutes(), 2) + ':' +\n    pad(date.getSeconds(), 2) + '.' +\n    pad(date.getMilliseconds(), 3)\n\n  if (offset < 0) {\n    ret += '-'\n    offset *= -1\n  } else { ret += '+' }\n\n  ret += pad(Math.floor(offset / 60), 2) + ':' + pad(offset % 60, 2)\n  if (isBCYear) ret += ' BC'\n  return ret\n}\n\nfunction dateToStringUTC (date) {\n  var year = date.getUTCFullYear()\n  var isBCYear = year < 1\n  if (isBCYear) year = Math.abs(year) + 1 // negative years are 1 off their BC representation\n\n  var ret = pad(year, 4) + '-' +\n    pad(date.getUTCMonth() + 1, 2) + '-' +\n    pad(date.getUTCDate(), 2) + 'T' +\n    pad(date.getUTCHours(), 2) + ':' +\n    pad(date.getUTCMinutes(), 2) + ':' +\n    pad(date.getUTCSeconds(), 2) + '.' +\n    pad(date.getUTCMilliseconds(), 3)\n\n  ret += '+00:00'\n  if (isBCYear) ret += ' BC'\n  return ret\n}\n\nfunction normalizeQueryConfig (config, values, callback) {\n  // can take in strings or config objects\n  config = (typeof (config) === 'string') ? { text: config } : config\n  if (values) {\n    if (typeof values === 'function') {\n      config.callback = values\n    } else {\n      config.values = values\n    }\n  }\n  if (callback) {\n    config.callback = callback\n  }\n  return config\n}\n\nconst md5 = function (string) {\n  return crypto.createHash('md5').update(string, 'utf-8').digest('hex')\n}\n\n// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html\nconst postgresMd5PasswordHash = function (user, password, salt) {\n  var inner = md5(password + user)\n  var outer = md5(Buffer.concat([Buffer.from(inner), salt]))\n  return 'md5' + outer\n}\n\nmodule.exports = {\n  prepareValue: function prepareValueWrapper (value) {\n    // this ensures that extra arguments do not get passed into prepareValue\n    // by accident, eg: from calling values.map(utils.prepareValue)\n    return prepareValue(value)\n  },\n  normalizeQueryConfig,\n  postgresMd5PasswordHash,\n  md5\n}\n","'use strict';\n\nvar url = require('url');\n\n//Parse method copied from https://github.com/brianc/node-postgres\n//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)\n//MIT License\n\n//parses a connection string\nfunction parse(str) {\n  var config;\n  //unix socket\n  if(str.charAt(0) === '/') {\n    config = str.split(' ');\n    return { host: config[0], database: config[1] };\n  }\n  // url parse expects spaces encoded as %20\n  if(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {\n    str = encodeURI(str).replace(/\\%25(\\d\\d)/g, \"%$1\");\n  }\n  var result = url.parse(str, true);\n  config = {};\n\n  if (result.query.application_name) {\n    config.application_name = result.query.application_name;\n  }\n  if (result.query.fallback_application_name) {\n    config.fallback_application_name = result.query.fallback_application_name;\n  }\n\n  config.port = result.port;\n  if(result.protocol == 'socket:') {\n    config.host = decodeURI(result.pathname);\n    config.database = result.query.db;\n    config.client_encoding = result.query.encoding;\n    return config;\n  }\n  config.host = result.hostname;\n\n  // result.pathname is not always guaranteed to have a '/' prefix (e.g. relative urls)\n  // only strip the slash if it is present.\n  var pathname = result.pathname;\n  if (pathname && pathname.charAt(0) === '/') {\n    pathname = result.pathname.slice(1) || null;\n  }\n  config.database = pathname && decodeURI(pathname);\n\n  var auth = (result.auth || ':').split(':');\n  config.user = auth[0];\n  config.password = auth.splice(1).join(':');\n\n  var ssl = result.query.ssl;\n  if (ssl === 'true' || ssl === '1') {\n    config.ssl = true;\n  }\n\n  return config;\n}\n\nmodule.exports = {\n  parse: parse\n};\n","var textParsers = require('./lib/textParsers');\nvar binaryParsers = require('./lib/binaryParsers');\nvar arrayParser = require('./lib/arrayParser');\nvar builtinTypes = require('./lib/builtins');\n\nexports.getTypeParser = getTypeParser;\nexports.setTypeParser = setTypeParser;\nexports.arrayParser = arrayParser;\nexports.builtins = builtinTypes;\n\nvar typeParsers = {\n  text: {},\n  binary: {}\n};\n\n//the empty parse function\nfunction noParse (val) {\n  return String(val);\n};\n\n//returns a function used to convert a specific type (specified by\n//oid) into a result javascript type\n//note: the oid can be obtained via the following sql query:\n//SELECT oid FROM pg_type WHERE typname = 'TYPE_NAME_HERE';\nfunction getTypeParser (oid, format) {\n  format = format || 'text';\n  if (!typeParsers[format]) {\n    return noParse;\n  }\n  return typeParsers[format][oid] || noParse;\n};\n\nfunction setTypeParser (oid, format, parseFn) {\n  if(typeof format == 'function') {\n    parseFn = format;\n    format = 'text';\n  }\n  typeParsers[format][oid] = parseFn;\n};\n\ntextParsers.init(function(oid, converter) {\n  typeParsers.text[oid] = converter;\n});\n\nbinaryParsers.init(function(oid, converter) {\n  typeParsers.binary[oid] = converter;\n});\n","var array = require('postgres-array');\n\nmodule.exports = {\n  create: function (source, transform) {\n    return {\n      parse: function() {\n        return array.parse(source, transform);\n      }\n    };\n  }\n};\n","var parseInt64 = require('pg-int8');\n\nvar parseBits = function(data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n  callback = callback || function(lastValue, newValue, bits) { return (lastValue * Math.pow(2, bits)) + newValue; };\n  var offsetBytes = offset >> 3;\n\n  var inv = function(value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  };\n\n  // read first (maybe partial) byte\n  var mask = 0xff;\n  var firstBits = 8 - (offset % 8);\n  if (bits < firstBits) {\n    mask = (0xff << (8 - bits)) & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> (offset % 8);\n  }\n\n  var result = 0;\n  if ((offset % 8) + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  }\n\n  // read bytes\n  var bytes = (bits + offset) >> 3;\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  }\n\n  // bits to read, that are not a complete byte\n  var lastBits = (bits + offset) % 8;\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> (8 - lastBits), lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function(data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  }\n\n  // parse mantissa\n  var precisionBitsCounter = 1;\n  var parsePrecisionBits = function(lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n      if ((newValue & (0x1 << (bits - i))) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);\n\n  // special cases\n  if (exponent == (Math.pow(2, exponentBits + 1) - 1)) {\n    if (mantissa === 0) {\n      return (sign === 0) ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  }\n\n  // normale number\n  return ((sign === 0) ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function(value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function(value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function(value) {\n  var sign = parseBits(value, 16, 32);\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + (16 * i)) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return ((sign === 0) ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function(isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1);\n\n  // discard usecs and shift from 2000 to 1970\n  var result = new Date((((sign === 0) ? 1 : -1) * rawValue / 1000) + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  }\n\n  // add microseconds to the date\n  result.usec = rawValue % 1000;\n  result.getMicroSeconds = function() {\n    return this.usec;\n  };\n  result.setMicroSeconds = function(value) {\n    this.usec = value;\n  };\n  result.getUTCMicroSeconds = function() {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function(value) {\n  var dim = parseBits(value, 32);\n\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n\n  var offset = 96;\n  var dims = [];\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32;\n\n    // ignore lower bounds\n    offset += 32;\n  }\n\n  var parseElement = function(elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32;\n\n    // parse null values\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n    if ((elementType == 0x17) || (elementType == 0x14)) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    }\n    else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += (length << 3)) >> 3);\n      return result;\n    }\n    else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function(dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n      dimension.unshift(count);\n    }\n    else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function(value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function(value) {\n  if(value === null) return null;\n  return (parseBits(value, 8) > 0);\n};\n\nvar init = function(register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};\n","/**\n * Following query was used to generate this file:\n\n SELECT json_object_agg(UPPER(PT.typname), PT.oid::int4 ORDER BY pt.oid)\n FROM pg_type PT\n WHERE typnamespace = (SELECT pgn.oid FROM pg_namespace pgn WHERE nspname = 'pg_catalog') -- Take only builting Postgres types with stable OID (extension types are not guaranted to be stable)\n AND typtype = 'b' -- Only basic types\n AND typelem = 0 -- Ignore aliases\n AND typisdefined -- Ignore undefined types\n */\n\nmodule.exports = {\n    BOOL: 16,\n    BYTEA: 17,\n    CHAR: 18,\n    INT8: 20,\n    INT2: 21,\n    INT4: 23,\n    REGPROC: 24,\n    TEXT: 25,\n    OID: 26,\n    TID: 27,\n    XID: 28,\n    CID: 29,\n    JSON: 114,\n    XML: 142,\n    PG_NODE_TREE: 194,\n    SMGR: 210,\n    PATH: 602,\n    POLYGON: 604,\n    CIDR: 650,\n    FLOAT4: 700,\n    FLOAT8: 701,\n    ABSTIME: 702,\n    RELTIME: 703,\n    TINTERVAL: 704,\n    CIRCLE: 718,\n    MACADDR8: 774,\n    MONEY: 790,\n    MACADDR: 829,\n    INET: 869,\n    ACLITEM: 1033,\n    BPCHAR: 1042,\n    VARCHAR: 1043,\n    DATE: 1082,\n    TIME: 1083,\n    TIMESTAMP: 1114,\n    TIMESTAMPTZ: 1184,\n    INTERVAL: 1186,\n    TIMETZ: 1266,\n    BIT: 1560,\n    VARBIT: 1562,\n    NUMERIC: 1700,\n    REFCURSOR: 1790,\n    REGPROCEDURE: 2202,\n    REGOPER: 2203,\n    REGOPERATOR: 2204,\n    REGCLASS: 2205,\n    REGTYPE: 2206,\n    UUID: 2950,\n    TXID_SNAPSHOT: 2970,\n    PG_LSN: 3220,\n    PG_NDISTINCT: 3361,\n    PG_DEPENDENCIES: 3402,\n    TSVECTOR: 3614,\n    TSQUERY: 3615,\n    GTSVECTOR: 3642,\n    REGCONFIG: 3734,\n    REGDICTIONARY: 3769,\n    JSONB: 3802,\n    REGNAMESPACE: 4089,\n    REGROLE: 4096\n};\n","var array = require('postgres-array')\nvar arrayParser = require('./arrayParser');\nvar parseDate = require('postgres-date');\nvar parseInterval = require('postgres-interval');\nvar parseByteA = require('postgres-bytea');\n\nfunction allowNull (fn) {\n  return function nullAllowed (value) {\n    if (value === null) return value\n    return fn(value)\n  }\n}\n\nfunction parseBool (value) {\n  if (value === null) return value\n  return value === 'TRUE' ||\n    value === 't' ||\n    value === 'true' ||\n    value === 'y' ||\n    value === 'yes' ||\n    value === 'on' ||\n    value === '1';\n}\n\nfunction parseBoolArray (value) {\n  if (!value) return null\n  return array.parse(value, parseBool)\n}\n\nfunction parseBaseTenInt (string) {\n  return parseInt(string, 10)\n}\n\nfunction parseIntegerArray (value) {\n  if (!value) return null\n  return array.parse(value, allowNull(parseBaseTenInt))\n}\n\nfunction parseBigIntegerArray (value) {\n  if (!value) return null\n  return array.parse(value, allowNull(function (entry) {\n    return parseBigInteger(entry).trim()\n  }))\n}\n\nvar parsePointArray = function(value) {\n  if(!value) { return null; }\n  var p = arrayParser.create(value, function(entry) {\n    if(entry !== null) {\n      entry = parsePoint(entry);\n    }\n    return entry;\n  });\n\n  return p.parse();\n};\n\nvar parseFloatArray = function(value) {\n  if(!value) { return null; }\n  var p = arrayParser.create(value, function(entry) {\n    if(entry !== null) {\n      entry = parseFloat(entry);\n    }\n    return entry;\n  });\n\n  return p.parse();\n};\n\nvar parseStringArray = function(value) {\n  if(!value) { return null; }\n\n  var p = arrayParser.create(value);\n  return p.parse();\n};\n\nvar parseDateArray = function(value) {\n  if (!value) { return null; }\n\n  var p = arrayParser.create(value, function(entry) {\n    if (entry !== null) {\n      entry = parseDate(entry);\n    }\n    return entry;\n  });\n\n  return p.parse();\n};\n\nvar parseIntervalArray = function(value) {\n  if (!value) { return null; }\n\n  var p = arrayParser.create(value, function(entry) {\n    if (entry !== null) {\n      entry = parseInterval(entry);\n    }\n    return entry;\n  });\n\n  return p.parse();\n};\n\nvar parseByteAArray = function(value) {\n  if (!value) { return null; }\n\n  return array.parse(value, allowNull(parseByteA));\n};\n\nvar parseInteger = function(value) {\n  return parseInt(value, 10);\n};\n\nvar parseBigInteger = function(value) {\n  var valStr = String(value);\n  if (/^\\d+$/.test(valStr)) { return valStr; }\n  return value;\n};\n\nvar parseJsonArray = function(value) {\n  if (!value) { return null; }\n\n  return array.parse(value, allowNull(JSON.parse));\n};\n\nvar parsePoint = function(value) {\n  if (value[0] !== '(') { return null; }\n\n  value = value.substring( 1, value.length - 1 ).split(',');\n\n  return {\n    x: parseFloat(value[0])\n  , y: parseFloat(value[1])\n  };\n};\n\nvar parseCircle = function(value) {\n  if (value[0] !== '<' && value[1] !== '(') { return null; }\n\n  var point = '(';\n  var radius = '';\n  var pointParsed = false;\n  for (var i = 2; i < value.length - 1; i++){\n    if (!pointParsed) {\n      point += value[i];\n    }\n\n    if (value[i] === ')') {\n      pointParsed = true;\n      continue;\n    } else if (!pointParsed) {\n      continue;\n    }\n\n    if (value[i] === ','){\n      continue;\n    }\n\n    radius += value[i];\n  }\n  var result = parsePoint(point);\n  result.radius = parseFloat(radius);\n\n  return result;\n};\n\nvar init = function(register) {\n  register(20, parseBigInteger); // int8\n  register(21, parseInteger); // int2\n  register(23, parseInteger); // int4\n  register(26, parseInteger); // oid\n  register(700, parseFloat); // float4/real\n  register(701, parseFloat); // float8/double\n  register(16, parseBool);\n  register(1082, parseDate); // date\n  register(1114, parseDate); // timestamp without timezone\n  register(1184, parseDate); // timestamp\n  register(600, parsePoint); // point\n  register(651, parseStringArray); // cidr[]\n  register(718, parseCircle); // circle\n  register(1000, parseBoolArray);\n  register(1001, parseByteAArray);\n  register(1005, parseIntegerArray); // _int2\n  register(1007, parseIntegerArray); // _int4\n  register(1028, parseIntegerArray); // oid[]\n  register(1016, parseBigIntegerArray); // _int8\n  register(1017, parsePointArray); // point[]\n  register(1021, parseFloatArray); // _float4\n  register(1022, parseFloatArray); // _float8\n  register(1231, parseFloatArray); // _numeric\n  register(1014, parseStringArray); //char\n  register(1015, parseStringArray); //varchar\n  register(1008, parseStringArray);\n  register(1009, parseStringArray);\n  register(1040, parseStringArray); // macaddr[]\n  register(1041, parseStringArray); // inet[]\n  register(1115, parseDateArray); // timestamp without time zone[]\n  register(1182, parseDateArray); // _date\n  register(1185, parseDateArray); // timestamp with time zone[]\n  register(1186, parseInterval);\n  register(1187, parseIntervalArray);\n  register(17, parseByteA);\n  register(114, JSON.parse.bind(JSON)); // json\n  register(3802, JSON.parse.bind(JSON)); // jsonb\n  register(199, parseJsonArray); // json[]\n  register(3807, parseJsonArray); // jsonb[]\n  register(3907, parseStringArray); // numrange[]\n  register(2951, parseStringArray); // uuid[]\n  register(791, parseStringArray); // money[]\n  register(1183, parseStringArray); // time[]\n  register(1270, parseStringArray); // timetz[]\n};\n\nmodule.exports = {\n  init: init\n};\n","'use strict'\n\nexports.parse = function (source, transform) {\n  return new ArrayParser(source, transform).parse()\n}\n\nclass ArrayParser {\n  constructor (source, transform) {\n    this.source = source\n    this.transform = transform || identity\n    this.position = 0\n    this.entries = []\n    this.recorded = []\n    this.dimension = 0\n  }\n\n  isEof () {\n    return this.position >= this.source.length\n  }\n\n  nextCharacter () {\n    var character = this.source[this.position++]\n    if (character === '\\\\') {\n      return {\n        value: this.source[this.position++],\n        escaped: true\n      }\n    }\n    return {\n      value: character,\n      escaped: false\n    }\n  }\n\n  record (character) {\n    this.recorded.push(character)\n  }\n\n  newEntry (includeEmpty) {\n    var entry\n    if (this.recorded.length > 0 || includeEmpty) {\n      entry = this.recorded.join('')\n      if (entry === 'NULL' && !includeEmpty) {\n        entry = null\n      }\n      if (entry !== null) entry = this.transform(entry)\n      this.entries.push(entry)\n      this.recorded = []\n    }\n  }\n\n  consumeDimensions () {\n    if (this.source[0] === '[') {\n      while (!this.isEof()) {\n        var char = this.nextCharacter()\n        if (char.value === '=') break\n      }\n    }\n  }\n\n  parse (nested) {\n    var character, parser, quote\n    this.consumeDimensions()\n    while (!this.isEof()) {\n      character = this.nextCharacter()\n      if (character.value === '{' && !quote) {\n        this.dimension++\n        if (this.dimension > 1) {\n          parser = new ArrayParser(this.source.substr(this.position - 1), this.transform)\n          this.entries.push(parser.parse(true))\n          this.position += parser.position - 2\n        }\n      } else if (character.value === '}' && !quote) {\n        this.dimension--\n        if (!this.dimension) {\n          this.newEntry()\n          if (nested) return this.entries\n        }\n      } else if (character.value === '\"' && !character.escaped) {\n        if (quote) this.newEntry(true)\n        quote = !quote\n      } else if (character.value === ',' && !quote) {\n        this.newEntry()\n      } else {\n        this.record(character.value)\n      }\n    }\n    if (this.dimension !== 0) {\n      throw new Error('array dimension not balanced')\n    }\n    return this.entries\n  }\n}\n\nfunction identity (value) {\n  return value\n}\n","// export the class if we are in a Node-like system.\nif (typeof module === 'object' && module.exports === exports)\n  exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      return (/^[0-9]+$/.test(id)) ? +id : id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.inspect = function() {\n  return '<SemVer \"' + this + '\">';\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.inspect = function() {\n  return '<SemVer Comparator \"' + this + '\">';\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.inspect = function() {\n  return '<SemVer Range \"' + this.range + '\">';\n};\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0- <1.3.0-\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm)\n          M = +M + 1\n        else\n          m = +m + 1\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        return true;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Use the define() function if we're in AMD land\nif (typeof define === 'function' && define.amd)\n  define(exports);\n","'use strict';\n\nvar path = require('path')\n  , Stream = require('stream').Stream\n  , Split = require('split')\n  , util = require('util')\n  , defaultPort = 5432\n  , isWin = (process.platform === 'win32')\n  , warnStream = process.stderr\n;\n\n\nvar S_IRWXG = 56     //    00070(8)\n  , S_IRWXO = 7      //    00007(8)\n  , S_IFMT  = 61440  // 00170000(8)\n  , S_IFREG = 32768  //  0100000(8)\n;\nfunction isRegFile(mode) {\n    return ((mode & S_IFMT) == S_IFREG);\n}\n\nvar fieldNames = [ 'host', 'port', 'database', 'user', 'password' ];\nvar nrOfFields = fieldNames.length;\nvar passKey = fieldNames[ nrOfFields -1 ];\n\n\nfunction warn() {\n    var isWritable = (\n        warnStream instanceof Stream &&\n          true === warnStream.writable\n    );\n\n    if (isWritable) {\n        var args = Array.prototype.slice.call(arguments).concat(\"\\n\");\n        warnStream.write( util.format.apply(util, args) );\n    }\n}\n\n\nObject.defineProperty(module.exports, 'isWin', {\n    get : function() {\n        return isWin;\n    } ,\n    set : function(val) {\n        isWin = val;\n    }\n});\n\n\nmodule.exports.warnTo = function(stream) {\n    var old = warnStream;\n    warnStream = stream;\n    return old;\n};\n\nmodule.exports.getFileName = function(env){\n    env = env || process.env;\n    var file = env.PGPASSFILE || (\n        isWin ?\n          path.join( env.APPDATA , 'postgresql', 'pgpass.conf' ) :\n          path.join( env.HOME, '.pgpass' )\n    );\n    return file;\n};\n\nmodule.exports.usePgPass = function(stats, fname) {\n    if (Object.prototype.hasOwnProperty.call(process.env, 'PGPASSWORD')) {\n        return false;\n    }\n\n    if (isWin) {\n        return true;\n    }\n\n    fname = fname || '<unkn>';\n\n    if (! isRegFile(stats.mode)) {\n        warn('WARNING: password file \"%s\" is not a plain file', fname);\n        return false;\n    }\n\n    if (stats.mode & (S_IRWXG | S_IRWXO)) {\n        /* If password file is insecure, alert the user and ignore it. */\n        warn('WARNING: password file \"%s\" has group or world access; permissions should be u=rw (0600) or less', fname);\n        return false;\n    }\n\n    return true;\n};\n\n\nvar matcher = module.exports.match = function(connInfo, entry) {\n    return fieldNames.slice(0, -1).reduce(function(prev, field, idx){\n        if (idx == 1) {\n            // the port\n            if ( Number( connInfo[field] || defaultPort ) === Number( entry[field] ) ) {\n                return prev && true;\n            }\n        }\n        return prev && (\n            entry[field] === '*' ||\n              entry[field] === connInfo[field]\n        );\n    }, true);\n};\n\n\nmodule.exports.getPassword = function(connInfo, stream, cb) {\n    var pass;\n    var lineStream = stream.pipe(new Split());\n\n    function onLine(line) {\n        var entry = parseLine(line);\n        if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {\n            pass = entry[passKey];\n            lineStream.end(); // -> calls onEnd(), but pass is set now\n        }\n    }\n\n    var onEnd = function() {\n        stream.destroy();\n        cb(pass);\n    };\n\n    var onErr = function(err) {\n        stream.destroy();\n        warn('WARNING: error on reading file: %s', err);\n        cb(undefined);\n    };\n\n    stream.on('error', onErr);\n    lineStream\n        .on('data', onLine)\n        .on('end', onEnd)\n        .on('error', onErr)\n    ;\n\n};\n\n\nvar parseLine = module.exports.parseLine = function(line) {\n    if (line.length < 11 || line.match(/^\\s+#/)) {\n        return null;\n    }\n\n    var curChar = '';\n    var prevChar = '';\n    var fieldIdx = 0;\n    var startIdx = 0;\n    var endIdx = 0;\n    var obj = {};\n    var isLastField = false;\n    var addToObj = function(idx, i0, i1) {\n        var field = line.substring(i0, i1);\n\n        if (! Object.hasOwnProperty.call(process.env, 'PGPASS_NO_DEESCAPE')) {\n            field = field.replace(/\\\\([:\\\\])/g, '$1');\n        }\n\n        obj[ fieldNames[idx] ] = field;\n    };\n\n    for (var i = 0 ; i < line.length-1 ; i += 1) {\n        curChar = line.charAt(i+1);\n        prevChar = line.charAt(i);\n\n        isLastField = (fieldIdx == nrOfFields-1);\n\n        if (isLastField) {\n            addToObj(fieldIdx, startIdx);\n            break;\n        }\n\n        if (i >= 0 && curChar == ':' && prevChar !== '\\\\') {\n            addToObj(fieldIdx, startIdx, i+1);\n\n            startIdx = i+2;\n            fieldIdx += 1;\n        }\n    }\n\n    obj = ( Object.keys(obj).length === nrOfFields ) ? obj : null;\n\n    return obj;\n};\n\n\nvar isValidEntry = module.exports.isValidEntry = function(entry){\n    var rules = {\n        // host\n        0 : function(x){\n            return x.length > 0;\n        } ,\n        // port\n        1 : function(x){\n            if (x === '*') {\n                return true;\n            }\n            x = Number(x);\n            return (\n                isFinite(x) &&\n                  x > 0 &&\n                  x < 9007199254740992 &&\n                  Math.floor(x) === x\n            );\n        } ,\n        // database\n        2 : function(x){\n            return x.length > 0;\n        } ,\n        // username\n        3 : function(x){\n            return x.length > 0;\n        } ,\n        // password\n        4 : function(x){\n            return x.length > 0;\n        }\n    };\n\n    for (var idx = 0 ; idx < fieldNames.length ; idx += 1) {\n        var rule = rules[idx];\n        var value = entry[ fieldNames[idx] ] || '';\n\n        var res = rule(value);\n        if (!res) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n","'use strict';\n\nvar path = require('path')\n  , fs = require('fs')\n  , helper = require('./helper.js')\n;\n\n\nmodule.exports = function(connInfo, cb) {\n    var file = helper.getFileName();\n    \n    fs.stat(file, function(err, stat){\n        if (err || !helper.usePgPass(stat, file)) {\n            return cb(undefined);\n        }\n\n        var st = fs.createReadStream(file);\n\n        helper.getPassword(connInfo, st, cb);\n    });\n};\n\nmodule.exports.warnTo = helper.warnTo;\n","'use strict'\n\nmodule.exports = function parseBytea (input) {\n  if (/^\\\\x/.test(input)) {\n    // new 'hex' style response (pg >9.0)\n    return new Buffer(input.substr(2), 'hex')\n  }\n  var output = ''\n  var i = 0\n  while (i < input.length) {\n    if (input[i] !== '\\\\') {\n      output += input[i]\n      ++i\n    } else {\n      if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {\n        output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8))\n        i += 4\n      } else {\n        var backslashes = 1\n        while (i + backslashes < input.length && input[i + backslashes] === '\\\\') {\n          backslashes++\n        }\n        for (var k = 0; k < Math.floor(backslashes / 2); ++k) {\n          output += '\\\\'\n        }\n        i += Math.floor(backslashes / 2) * 2\n      }\n    }\n  }\n  return new Buffer(output, 'binary')\n}\n","'use strict'\n\nvar DATE_TIME = /(\\d{1,})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})(\\.\\d{1,})?.*?( BC)?$/\nvar DATE = /^(\\d{1,})-(\\d{2})-(\\d{2})( BC)?$/\nvar TIME_ZONE = /([Z+-])(\\d{2})?:?(\\d{2})?:?(\\d{2})?/\nvar INFINITY = /^-?infinity$/\n\nmodule.exports = function parseDate (isoDate) {\n  if (INFINITY.test(isoDate)) {\n    // Capitalize to Infinity before passing to Number\n    return Number(isoDate.replace('i', 'I'))\n  }\n  var matches = DATE_TIME.exec(isoDate)\n\n  if (!matches) {\n    // Force YYYY-MM-DD dates to be parsed as local time\n    return getDate(isoDate) || null\n  }\n\n  var isBC = !!matches[8]\n  var year = parseInt(matches[1], 10)\n  if (isBC) {\n    year = bcYearToNegativeYear(year)\n  }\n\n  var month = parseInt(matches[2], 10) - 1\n  var day = matches[3]\n  var hour = parseInt(matches[4], 10)\n  var minute = parseInt(matches[5], 10)\n  var second = parseInt(matches[6], 10)\n\n  var ms = matches[7]\n  ms = ms ? 1000 * parseFloat(ms) : 0\n\n  var date\n  var offset = timeZoneOffset(isoDate)\n  if (offset != null) {\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, ms))\n\n    // Account for years from 0 to 99 being interpreted as 1900-1999\n    // by Date.UTC / the multi-argument form of the Date constructor\n    if (is0To99(year)) {\n      date.setUTCFullYear(year)\n    }\n\n    date.setTime(date.getTime() - offset)\n  } else {\n    date = new Date(year, month, day, hour, minute, second, ms)\n\n    if (is0To99(year)) {\n      date.setFullYear(year)\n    }\n  }\n\n  return date\n}\n\nfunction getDate (isoDate) {\n  var matches = DATE.exec(isoDate)\n  if (!matches) {\n    return\n  }\n\n  var year = parseInt(matches[1], 10)\n  var isBC = !!matches[4]\n  if (isBC) {\n    year = bcYearToNegativeYear(year)\n  }\n\n  var month = parseInt(matches[2], 10) - 1\n  var day = matches[3]\n  // YYYY-MM-DD will be parsed as local time\n  var date = new Date(year, month, day)\n\n  if (is0To99(year)) {\n    date.setFullYear(year)\n  }\n\n  return date\n}\n\n// match timezones:\n// Z (UTC)\n// -05\n// +06:30\nfunction timeZoneOffset (isoDate) {\n  var zone = TIME_ZONE.exec(isoDate.split(' ')[1])\n  if (!zone) return\n  var type = zone[1]\n\n  if (type === 'Z') {\n    return 0\n  }\n  var sign = type === '-' ? -1 : 1\n  var offset = parseInt(zone[2], 10) * 3600 +\n    parseInt(zone[3] || 0, 10) * 60 +\n    parseInt(zone[4] || 0, 10)\n\n  return offset * sign * 1000\n}\n\nfunction bcYearToNegativeYear (year) {\n  // Account for numerical difference between representations of BC years\n  // See: https://github.com/bendrucker/postgres-date/issues/5\n  return -(year - 1)\n}\n\nfunction is0To99 (num) {\n  return num >= 0 && num < 100\n}\n","'use strict'\n\nvar extend = require('xtend/mutable')\n\nmodule.exports = PostgresInterval\n\nfunction PostgresInterval (raw) {\n  if (!(this instanceof PostgresInterval)) {\n    return new PostgresInterval(raw)\n  }\n  extend(this, parse(raw))\n}\nvar properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years']\nPostgresInterval.prototype.toPostgres = function () {\n  var filtered = properties.filter(this.hasOwnProperty, this)\n\n  // In addition to `properties`, we need to account for fractions of seconds.\n  if (this.milliseconds && filtered.indexOf('seconds') < 0) {\n    filtered.push('seconds')\n  }\n\n  if (filtered.length === 0) return '0'\n  return filtered\n    .map(function (property) {\n      var value = this[property] || 0\n\n      // Account for fractional part of seconds,\n      // remove trailing zeroes.\n      if (property === 'seconds' && this.milliseconds) {\n        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\\.?0+$/, '')\n      }\n\n      return value + ' ' + property\n    }, this)\n    .join(' ')\n}\n\nvar propertiesISOEquivalent = {\n  years: 'Y',\n  months: 'M',\n  days: 'D',\n  hours: 'H',\n  minutes: 'M',\n  seconds: 'S'\n}\nvar dateProperties = ['years', 'months', 'days']\nvar timeProperties = ['hours', 'minutes', 'seconds']\n// according to ISO 8601\nPostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {\n  var datePart = dateProperties\n    .map(buildProperty, this)\n    .join('')\n\n  var timePart = timeProperties\n    .map(buildProperty, this)\n    .join('')\n\n  return 'P' + datePart + 'T' + timePart\n\n  function buildProperty (property) {\n    var value = this[property] || 0\n\n    // Account for fractional part of seconds,\n    // remove trailing zeroes.\n    if (property === 'seconds' && this.milliseconds) {\n      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '')\n    }\n\n    return value + propertiesISOEquivalent[property]\n  }\n}\n\nvar NUMBER = '([+-]?\\\\d+)'\nvar YEAR = NUMBER + '\\\\s+years?'\nvar MONTH = NUMBER + '\\\\s+mons?'\nvar DAY = NUMBER + '\\\\s+days?'\nvar TIME = '([+-])?([\\\\d]*):(\\\\d\\\\d):(\\\\d\\\\d)\\\\.?(\\\\d{1,6})?'\nvar INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {\n  return '(' + regexString + ')?'\n})\n  .join('\\\\s*'))\n\n// Positions of values in regex match\nvar positions = {\n  years: 2,\n  months: 4,\n  days: 6,\n  hours: 9,\n  minutes: 10,\n  seconds: 11,\n  milliseconds: 12\n}\n// We can use negative time\nvar negatives = ['hours', 'minutes', 'seconds', 'milliseconds']\n\nfunction parseMilliseconds (fraction) {\n  // add omitted zeroes\n  var microseconds = fraction + '000000'.slice(fraction.length)\n  return parseInt(microseconds, 10) / 1000\n}\n\nfunction parse (interval) {\n  if (!interval) return {}\n  var matches = INTERVAL.exec(interval)\n  var isNegative = matches[8] === '-'\n  return Object.keys(positions)\n    .reduce(function (parsed, property) {\n      var position = positions[property]\n      var value = matches[position]\n      // no empty string\n      if (!value) return parsed\n      // milliseconds are actually microseconds (up to 6 digits)\n      // with omitted trailing zeroes.\n      value = property === 'milliseconds'\n        ? parseMilliseconds(value)\n        : parseInt(value, 10)\n      // no zeros\n      if (!value) return parsed\n      if (isNegative && ~negatives.indexOf(property)) {\n        value *= -1\n      }\n      parsed[property] = value\n      return parsed\n    }, {})\n}\n","//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar through = require('through')\nvar Decoder = require('string_decoder').StringDecoder\n\nmodule.exports = split\n\n//TODO pass in a function to map across the lines.\n\nfunction split (matcher, mapper, options) {\n  var decoder = new Decoder()\n  var soFar = ''\n  var maxLength = options && options.maxLength;\n  var trailing = options && options.trailing === false ? false : true\n  if('function' === typeof matcher)\n    mapper = matcher, matcher = null\n  if (!matcher)\n    matcher = /\\r?\\n/\n\n  function emit(stream, piece) {\n    if(mapper) {\n      try {\n        piece = mapper(piece)\n      }\n      catch (err) {\n        return stream.emit('error', err)\n      }\n      if('undefined' !== typeof piece)\n        stream.queue(piece)\n    }\n    else\n      stream.queue(piece)\n  }\n\n  function next (stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    if (maxLength && soFar.length > maxLength)\n      return stream.emit('error', new Error('maximum buffer reached'))\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i]\n      emit(stream, piece)\n    }\n  }\n\n  return through(function (b) {\n    next(this, decoder.write(b))\n  },\n  function () {\n    if(decoder.end)\n      next(this, decoder.end())\n    if(trailing && soFar != null)\n      emit(this, soFar)\n    this.queue(null)\n  })\n}\n","var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","require(\"dotenv\").config();\n\nconst pg = require(\"pg\");\nconst { ApolloServer } = require(\"apollo-server\");\nconst { makeSchemaAndPlugin } = require(\"postgraphile-apollo-server\");\nconst { makeExtendSchemaPlugin, gql } = require(\"graphile-utils\");\nconst PgSimplifyInflectorPlugin = require(\"@graphile-contrib/pg-simplify-inflector\");\n\nconst pgPool = new pg.Pool({\n  connectionString: process.env.DATABASE_URL\n});\n\nasync function main() {\n  const { schema, plugin } = await makeSchemaAndPlugin(\n    pgPool,\n    \"public\",\n    {\n      // PostGraphile options, see:\n      // https://www.graphile.org/postgraphile/usage-library/\n      dynamicJson: true,\n      appendPlugins: [\n        PgSimplifyInflectorPlugin, \n      ],\n      \n    }\n  );\n\n  const server = new ApolloServer({\n    schema,\n    plugins: [plugin]\n  });\n\n  const { url } = await server.listen();\n  console.log(` Server ready at ${url}`);\n}\n\nmain().catch(e => {\n  console.error(e);\n  process.exit(1);\n});\n","module.exports = require(\"@graphile-contrib/pg-simplify-inflector\");","module.exports = require(\"apollo-server\");","module.exports = require(\"assert\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"dotenv\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"graphile-utils\");","module.exports = require(\"net\");","module.exports = require(\"path\");","module.exports = require(\"pg-native\");","module.exports = require(\"postgraphile-apollo-server\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"tls\");","module.exports = require(\"url\");","module.exports = require(\"util\");"],"sourceRoot":""}